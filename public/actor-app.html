<!DOCTYPE html>
<!-- DANGER! WARNING! THEATER! app for displaying PDF files to follow Stage Manager scrolling -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> <!-- Prevent user zoom -->
    <title>Actor App - PlayScroller</title>
    <!-- Tailwind CSS for mobile-first, responsive design -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent body scroll */
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            /* Hide scrollbars for body if they appear, though main scroll is on pdf-viewer-wrapper */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }
        body::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        #pdf-viewer-wrapper {
            position: relative; /* For positioning highlight divs */
            width: 100%;
            height: 100%; /* Take full available space */
            overflow-y: hidden; /* Disable manual scrolling */
            scroll-behavior: smooth; /* Smooth scrolling for programmatic jumps */
            /* Hide scrollbars for pdf-viewer-wrapper too, as SM controls scroll */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }
        #pdf-viewer-wrapper::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        /* Wrapper for each PDF page (canvas + highlight overlay) */
        .pdf-page-wrapper {
            position: relative; /* Crucial for absolute positioning of canvas and overlay */
            margin: 0 auto 8px auto; /* Centered, with bottom margin */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Subtle shadow for visual separation */
            display: block; /* Ensure it takes up full width for centering */
        }

        canvas {
            display: block;
            margin: 0; /* Managed by parent .pdf-page-wrapper */
            position: absolute; /* Positioned within .pdf-page-wrapper */
            top: 0;
            left: 0;
            z-index: 1; /* Ensure canvas is below overlay */
        }

        /* This is the new container for highlights */
        .highlight-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; /* Crucial: ensures it's above the canvas */
            pointer-events: none; /* Allows interaction with elements beneath */
            overflow: hidden; /* Prevent highlights from spilling out */
        }

        /* --- Hamburger Menu Styles --- */
        #menu-button {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 9999px; /* circle */
            padding: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: block; /* Ensure it's block so we can use `display: none` for hiding */
        }
        #menu-button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        #side-menu {
            position: fixed;
            top: 0;
            right: 0;
            width: 250px;
            height: 100%;
            background-color: #fff;
            box-shadow: -4px 0 10px rgba(0,0,0,0.1);
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            z-index: 999;
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }
        #side-menu.open {
            transform: translateX(0);
        }
        #side-menu ul {
            list-style: none;
            padding: 0;
            margin: 1rem 0;
            flex-grow: 1; /* Push close button to bottom if menu items are few */
        }
        #side-menu li {
            margin-bottom: 0.75rem;
        }
        #side-menu button {
            width: 100%;
            padding: 0.75rem;
            background-color: #f3f4f6; /* Light gray */
            border-radius: 0.5rem;
            text-align: left;
            font-size: 1rem;
            color: #1f2937; /* Dark gray */
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #side-menu button:hover {
            background-color: #e5e7eb; /* Lighter gray */
        }

        /* --- Custom highlight styling --- */
        .highlight {
            position: absolute;
            background-color: rgba(255, 255, 0, 0.4); /* Semi-transparent yellow */
            /* NO BORDER - removed any border styling */
            border: none !important;
            border-radius: 2px;
            pointer-events: none; /* Allow interaction with elements beneath */
            z-index: 10;
            mix-blend-mode: multiply; /* Better blending with text */
            /* Ensure no outline or box-shadow */
            outline: none !important;
            box-shadow: none !important;
        }

        /* --- Modal for Highlight Input --- */
        #highlight-modal {
            background-color: rgba(0, 0, 0, 0.7);
        }

        /* Debug panel styles */
        #debug-panel {
            font-family: monospace;
        }

        #debug-content {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
        }

        #debug-button {
            z-index: 1001; /* Above everything */
        }

        /* Loading indicator for highlight search */
        .highlight-loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 10000;
            display: none;
        }

        /* --- QR Code Modal - Full Screen --- */
        #qr-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        #qr-modal-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            max-width: 1000px;
            text-align: center;
        }

        #qr-code-display {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        #qr-code-display canvas {
            max-width: 90vw;
            max-height: 70vh;
            width: auto !important;
            height: auto !important;
            border: 10px solid white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .qr-title {
            font-size: 2.5rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 1.5rem;
        }

        .qr-instructions {
            font-size: 1.2rem;
            color: #4b5563;
            margin-bottom: 2rem;
            max-width: 600px;
        }

        .session-info {
            background-color: #f3f4f6;
            padding: 15px 25px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 1.1rem;
            margin-bottom: 2rem;
            border: 2px solid #e5e7eb;
        }

        .close-qr-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-qr-btn:hover {
            background-color: rgba(0, 0, 0, 0.9);
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }
    </style>
    <!-- PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js"></script> <!-- Worker also needed -->
    <!-- QRious for QR code generation -->
    <script src="https://unpkg.com/qrious@4.0.2/dist/qrious.min.js"></script>
</head>
<body class="p-0"> <!-- Remove default padding -->

    <!-- Main Content Area - PDF Viewer -->
    <div id="pdf-viewer-wrapper">
        <!-- PDF Canvases and highlight divs will be rendered here -->
        <p id="loading-message" class="text-center py-12 text-gray-500 text-lg">Connecting to session and loading PDF...</p>
    </div>

    <!-- Hamburger Menu Button -->
    <button id="menu-button">
        <!-- Hamburger Icon (SVG for crispness) -->
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
    </button>

    <!-- Side Menu Panel -->
    <div id="side-menu">
        <button class="self-end p-2 bg-transparent text-gray-500 hover:text-gray-800" onclick="window.toggleMenu()">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
        </button>
        <ul>
            <li><button id="highlight-menu-item" onclick="window.handleHighlightClick()">Highlight Text...</button></li>
            <li><button id="show-qr-btn" class="hidden">Show Session QR Code</button></li>
            <li><button id="exit-menu-item" onclick="window.exitApp()">Exit</button></li>
        </ul>
    </div>

    <!-- Generic Modal for Highlight Input / Errors -->
    <div id="modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h3 id="modal-title" class="text-xl font-bold mb-4 text-gray-800"></h3>
            <p id="modal-message" class="text-gray-700 mb-6"></p>
            <!-- Highlight Input specific elements -->
            <input type="text" id="highlight-text-input" placeholder="Enter text to highlight"
                   class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm p-3 border focus:border-indigo-500 focus:ring-indigo-500 hidden">
            <div id="modal-buttons" class="flex justify-end space-x-4 mt-6">
                <button id="modal-cancel-btn" class="py-2 px-4 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 hidden">Cancel</button>
                <button id="modal-ok-btn" class="py-2 px-4 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">Highlight</button>
            </div>
        </div>
    </div>

    <!-- Modal for QR Code Display - FULL SCREEN -->
    <div id="qr-modal" class="hidden">
        <button class="close-qr-btn" id="qr-modal-close">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
        </button>
        <div id="qr-modal-content">
            <h2 class="qr-title">Session QR Code</h2>
            <p class="qr-instructions">Scan this QR code to join the same session</p>
            <div id="qr-code-display">
                <!-- QR code will be rendered here -->
            </div>
            <div class="session-info">
                Session ID: <span id="session-id-display"></span>
            </div>
        </div>
    </div>

    <!-- Debug Panel for Tablet Testing -->
    <div id="debug-panel" class="fixed bottom-0 left-0 right-0 bg-black bg-opacity-80 text-white p-3 z-50 hidden">
        <div class="flex justify-between items-center">
            <h3 class="font-bold">Debug Info</h3>
            <button onclick="window.toggleDebugPanel()" class="bg-red-500 px-3 py-1 rounded">Ã—</button>
        </div>
        <div id="debug-content" class="mt-2 text-sm overflow-auto max-h-32">
            <!-- Debug messages will appear here -->
        </div>
    </div>

    <!-- Quick Debug Button -->
    <button id="debug-button" onclick="window.toggleDebugPanel()"
            class="fixed bottom-4 right-4 bg-blue-500 text-white p-3 rounded-full shadow-lg z-50">
        Debug
    </button>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getDatabase, ref, onValue } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // --- Global Firebase Variables ---
        const firebaseConfig = {
          apiKey: "AIzaSyBG9pzEdllxWnZu0zYQMXqEFzJWNAVv6Lw",
          authDomain: "playscroller.firebaseapp.com",
          projectId: "playscroller",
          storageBucket: "playscroller.appspot.com",
          messagingSenderId: "86147104940",
          appId: "1:86147104940:web:f1bd908e1206795f9d1f09"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);

        let rtdb, auth, userId;
        let pdfDoc = null;
        let pdfViewerWrapper; // Our main scrollable div
        let currentSessionId = null;
        let currentPdfUrl = null;
        let activeHighlightText = ""; // Stores the text currently being highlighted

        // Ensure PDF.js worker is set up
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        // --- Debug Functions for Tablet Testing ---
        let debugMessages = [];

        window.showDebugMessage = (message, type = 'info') => {
            const timestamp = new Date().toLocaleTimeString();
            const formattedMessage = `[${timestamp}] ${message}`;
            debugMessages.push({ message: formattedMessage, type });

            // Keep only last 10 messages
            if (debugMessages.length > 10) {
                debugMessages.shift();
            }

            // Update debug panel if visible
            const debugContent = document.getElementById('debug-content');
            if (debugContent) {
                debugContent.innerHTML = debugMessages
                    .map(msg => `<div class="${msg.type === 'error' ? 'text-red-300' : 'text-green-300'}">${msg.message}</div>`)
                    .join('');
                debugContent.scrollTop = debugContent.scrollHeight;
            }
        };

        window.toggleDebugPanel = () => {
            const panel = document.getElementById('debug-panel');
            const button = document.getElementById('debug-button');

            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                button.textContent = 'Hide Debug';
                button.classList.remove('bg-blue-500');
                button.classList.add('bg-red-500');
            } else {
                panel.classList.add('hidden');
                button.textContent = 'Debug';
                button.classList.remove('bg-red-500');
                button.classList.add('bg-blue-500');
            }
        };

        // --- UI Utility Functions ---
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const highlightTextInput = document.getElementById('highlight-text-input');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        window.showModal = (title, message, isError = true, showInput = false, onOk = null, onCancel = null) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalTitle.className = isError ? 'text-xl font-bold mb-4 text-red-600' : 'text-xl font-bold mb-4 text-green-600';

            if (showInput) {
                highlightTextInput.value = activeHighlightText; // Pre-fill with current highlight
                highlightTextInput.classList.remove('hidden');
                modalCancelBtn.classList.remove('hidden');
                modalOkBtn.textContent = 'Highlight'; // Change text for highlight action

                // Store the callbacks for later use
                let okCallback = onOk;
                let cancelCallback = onCancel;

                // Set up button handlers
                modalOkBtn.onclick = async () => {
                    // Get the input value
                    const inputValue = highlightTextInput.value;

                    // Disable the OK button while processing
                    modalOkBtn.disabled = true;
                    modalOkBtn.textContent = 'Searching...';
                    modalOkBtn.classList.add('opacity-50', 'cursor-not-allowed');

                    try {
                        // Call the callback and wait for it to complete
                        if (okCallback) {
                            await okCallback(inputValue); // WAIT for callback to complete
                        }
                    } finally {
                        // Always close the modal after callback completes
                        window.closeModal();
                    }
                };

                modalCancelBtn.onclick = () => {
                    if (cancelCallback) {
                        cancelCallback();
                    }
                    window.closeModal();
                };

                // Focus the input field
                setTimeout(() => {
                    highlightTextInput.focus();
                    highlightTextInput.select();
                }, 100);
            } else {
                highlightTextInput.classList.add('hidden');
                modalCancelBtn.classList.add('hidden');
                modalOkBtn.textContent = 'OK'; // Default OK text

                // For non-input modals, use simple close
                modalOkBtn.onclick = window.closeModal;
                modalCancelBtn.onclick = window.closeModal;
            }

            modal.classList.remove('hidden');
        };

        window.closeModal = () => {
            modal.classList.add('hidden');
            // Clear input field
            highlightTextInput.value = '';
            // Reset OK button state
            modalOkBtn.disabled = false;
            modalOkBtn.textContent = 'Highlight';
            modalOkBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        };

        // --- QR Code Modal Functions ---
        function showQrModal() {
            if (!currentSessionId || !currentPdfUrl) {
                window.showModal('No Session', 'Not connected to a session yet.', true);
                return;
            }

            // Generate the actor app URL (same as current page URL)
            const actorAppUrl = window.location.origin + window.location.pathname;
            const actorSyncUrl = `${actorAppUrl}?session_id=${currentSessionId}&pdf_url=${encodeURIComponent(currentPdfUrl)}`;

            window.showDebugMessage(`QR Code URL: ${actorSyncUrl}`, 'info');

            // Update session ID display
            document.getElementById('session-id-display').textContent = currentSessionId;

            // Generate QR code - make it as large as possible
            const qrDisplay = document.getElementById('qr-code-display');
            qrDisplay.innerHTML = '';

            // Create container for QR code
            const qrContainer = document.createElement('div');
            qrContainer.style.width = '100%';
            qrContainer.style.height = '100%';
            qrContainer.style.display = 'flex';
            qrContainer.style.justifyContent = 'center';
            qrContainer.style.alignItems = 'center';

            const qrCanvas = document.createElement('canvas');
            qrContainer.appendChild(qrCanvas);
            qrDisplay.appendChild(qrContainer);

            // Calculate optimal size based on screen dimensions
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const qrSize = Math.min(screenWidth, screenHeight) * 0.8;

            new QRious({
                element: qrCanvas,
                value: actorSyncUrl,
                size: qrSize,
                background: '#ffffff',
                foreground: '#000000', // Black for maximum contrast
                level: 'H' // Highest error correction
            });

            document.getElementById('qr-modal').classList.remove('hidden');

            // Hide menu button when QR code is shown
            document.getElementById('menu-button').classList.add('hidden');
        }

        function closeQrModal() {
            document.getElementById('qr-modal').classList.add('hidden');

            // Show menu button again
            document.getElementById('menu-button').classList.remove('hidden');
        }

        // --- Menu Functions ---
        const menuButton = document.getElementById('menu-button');
        const sideMenu = document.getElementById('side-menu');

        window.toggleMenu = () => {
            sideMenu.classList.toggle('open');
            // Hide menu button when side menu is open, show when closed
            menuButton.style.display = sideMenu.classList.contains('open') ? 'none' : 'block';
        };

        // Helper function to clean search text
        function cleanSearchText(text) {
            // Remove spaces ONLY from the beginning and end
            let cleaned = text.trim();
            window.showDebugMessage(`Cleaned search text: "${text}" -> "${cleaned}"`, 'info');
            return cleaned;
        }

        // UPDATED: handleHighlightClick function - MODAL CLOSES AFTER HIGHLIGHTING COMPLETES
        window.handleHighlightClick = () => {
            window.toggleMenu(); // Close the side menu
            window.showModal('Highlight Text 0.5.8',
                'Enter text to highlight across the script:\n\nNote: Leading/trailing spaces will be ignored.',
                false, true,
                async (text) => { // Make callback async
                    window.showDebugMessage(`User entered text: "${text}"`, 'info');

                    // Clear existing highlights first (ALWAYS do this)
                    document.querySelectorAll('.highlight').forEach(el => el.remove());

                    if (!text || text.trim() === "") {
                        activeHighlightText = "";
                        window.showDebugMessage("Cleared all highlights (blank input)", 'info');
                        // NO MODAL - just clear highlights silently
                        return; // Return immediately for blank input
                    } else {
                        // Clean the search text (trim only)
                        activeHighlightText = cleanSearchText(text);
                        window.showDebugMessage(`Searching for: "${activeHighlightText}" (case-insensitive)`, 'info');

                        // Call the highlight function and WAIT for it to complete
                        await renderHighlightsForText(activeHighlightText);
                    }
                },
                () => {
                    window.showDebugMessage("Highlight cancelled", 'info');
                }
            );
        };

        // Function to handle Show QR Code button click
        window.handleShowQrClick = () => {
            window.toggleMenu(); // Close the side menu
            showQrModal();
        };

        window.exitApp = () => {
            if (window.opener) {
                window.close(); // Try to close the current tab/window
            } else {
                // If it's the main window, simply show a message or redirect.
                // Cannot force close window not opened by script.
                window.showModal('Exit App', 'You can close this tab/window manually.', false);
            }
        };

        // --- Core App Initialization ---
        async function initializeFirebase() {
            try {
                if (!firebaseConfig.apiKey || Object.keys(firebaseConfig).length === 0) {
                     window.showModal('Configuration Error', 'Firebase API Key is missing or Firebase configuration is empty. Cannot initialize.', true);
                     return;
                }

                rtdb = getDatabase(app);
                auth = getAuth(app);

                await signInAnonymously(auth);
                userId = auth.currentUser?.uid || crypto.randomUUID();
                window.showDebugMessage("Actor User ID: " + userId, 'info');

                // Extract session_id and pdf_url from QR code URL
                const urlParams = new URLSearchParams(window.location.search);
                const sessionIdFromUrl = urlParams.get('session_id');
                const pdfUrlFromUrl = urlParams.get('pdf_url');

                if (!sessionIdFromUrl || !pdfUrlFromUrl) {
                    window.showModal('Connection Error', 'Missing Session ID or PDF URL in QR code link. Please scan the Stage Manager\'s QR code.', true);
                    document.getElementById('loading-message').textContent = 'Error: Missing session details.';
                    return;
                }

                currentSessionId = sessionIdFromUrl;
                currentPdfUrl = pdfUrlFromUrl;
                window.showDebugMessage(`Connected to Session: ${currentSessionId}, PDF URL: ${currentPdfUrl}`, 'info');

                // Show QR button now that we have session info
                document.getElementById('show-qr-btn').classList.remove('hidden');

                document.getElementById('loading-message').textContent = `Connected to session ${currentSessionId}. Loading PDF...`;

                // Load and render PDF first
                await loadAndRenderPDF(currentPdfUrl);

                // Start listening for scroll state changes
                listenForScrollState();

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                window.showModal('Initialization Failed', `Could not initialize Firebase: ${error.message}`, true);
                document.getElementById('loading-message').textContent = 'Error: Firebase initialization failed.';
            }
        }

        // --- PDF Rendering Functions ---
        async function renderPage(pageNumber, pdfPage) {
            // Scale to fit width of the viewer wrapper (which is 100vw)
            const scale = pdfViewerWrapper.clientWidth / pdfPage.getViewport({ scale: 1 }).width;
            const viewport = pdfPage.getViewport({ scale: scale });

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            canvas.id = `pdf-page-${pageNumber}`;
            canvas.setAttribute('data-page', pageNumber);
            // No absolute positioning here, will be handled by parent for full width

            const pageDiv = document.createElement('div');
            pageDiv.id = `page-div-${pageNumber}`;
            pageDiv.classList.add('pdf-page-wrapper'); // Add this class for consistent styling
            pageDiv.style.width = `${viewport.width}px`; // Explicit width to ensure centering and context
            pageDiv.style.height = `${viewport.height}px`; // Explicit height

            // Create the highlight overlay
            const highlightOverlay = document.createElement('div');
            highlightOverlay.className = 'highlight-overlay';
            highlightOverlay.id = `highlight-overlay-${pageNumber}`; // Give it an ID for targeting

            window.showDebugMessage(`Created overlay for page ${pageNumber}: ${highlightOverlay.id}`, 'info');

            pageDiv.appendChild(canvas);
            pageDiv.appendChild(highlightOverlay); // Append overlay AFTER canvas for z-index
            pdfViewerWrapper.appendChild(pageDiv);

            await pdfPage.render({ canvasContext: context, viewport: viewport }).promise;

            // Store text content and viewport for later highlighting
            const textContent = await pdfPage.getTextContent();
            pdfPage.textContentItems = textContent.items; // Attach for later use
            pdfPage.viewport = viewport; // Also store viewport for highlight positioning
        }

        async function loadAndRenderPDF(pdfUrl) {
            pdfViewerWrapper.innerHTML = '<p id="loading-message" class="text-center py-12 text-gray-500 text-lg">Loading PDF, please wait...</p>';
            try {
                const pdf = await pdfjsLib.getDocument(pdfUrl).promise;
                pdfDoc = pdf;
                pdfViewerWrapper.innerHTML = ''; // Clear loading message

                window.showDebugMessage(`PDF loaded: ${pdf.numPages} pages`, 'info');

                // Render all pages
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    await renderPage(i, page);
                }

                // Initial scroll to top
                pdfViewerWrapper.scrollTop = 0;

            } catch (error) {
                console.error("PDF Loading Error:", error);
                window.showModal('PDF Loading Error', `Could not load PDF from URL. Check the URL and CORS settings. ${error.message}`, true);
                pdfViewerWrapper.innerHTML = '<p id="loading-message" class="text-center py-12 text-gray-500 text-lg">PDF loading failed.</p>';
                pdfDoc = null; // Reset document
            }
        }

        // --- Highlighting Logic ---
        async function renderHighlightsForText(searchText) {
            window.showDebugMessage(`STARTING renderHighlightsForText("${searchText}")`, 'info');

            // Clear all existing highlights before re-rendering
            const existingHighlights = document.querySelectorAll('.highlight').length;
            window.showDebugMessage(`Clearing ${existingHighlights} existing highlights`, 'info');
            document.querySelectorAll('.highlight').forEach(el => el.remove());

            // Show loading indicator
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'highlight-loading';
            loadingIndicator.textContent = `Searching for "${searchText}"...`;
            loadingIndicator.style.display = 'block';
            document.body.appendChild(loadingIndicator);

            window.showDebugMessage(`Searching for "${searchText}" in PDF (case-insensitive)...`, 'info');

            if (!pdfDoc) {
                window.showDebugMessage("ERROR: No PDF document loaded", 'error');
                if (loadingIndicator.parentNode) {
                    loadingIndicator.parentNode.removeChild(loadingIndicator);
                }
                return;
            }

            // Prepare search text: case-insensitive and trim only
            const searchTextLower = searchText.toLowerCase().trim();
            const searchTextLowerNoSpaces = searchTextLower.replace(/\s+/g, ''); // For matching without spaces
            let totalHighlights = 0;
            let totalMatches = 0;

            // Search through all pages
            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                try {
                    window.showDebugMessage(`Processing page ${pageNum}...`, 'info');
                    const page = await pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();

                    // Get the highlight overlay for this page
                    const highlightOverlay = document.getElementById(`highlight-overlay-${pageNum}`);
                    if (!highlightOverlay) {
                        window.showDebugMessage(`No overlay for page ${pageNum}`, 'error');
                        continue;
                    }

                    // Get the canvas to match dimensions
                    const canvas = document.getElementById(`pdf-page-${pageNum}`);
                    if (!canvas) {
                        window.showDebugMessage(`No canvas for page ${pageNum}`, 'error');
                        continue;
                    }

                    // Get the viewport and scale
                    const viewport = page.getViewport({ scale: 1 });
                    const scale = canvas.width / viewport.width;

                    let pageHighlights = 0;
                    let pageMatches = 0;

                    // Build concatenated text from all text items on this page WITH estimated spaces
                    let pageTextWithSpaces = '';
                    let pageTextWithoutSpaces = '';
                    const textItems = textContent.items;

                    // Create a mapping of text positions
                    const textPositions = [];

                    // First pass: build the full page text and track positions
                    for (let i = 0; i < textItems.length; i++) {
                        const textItem = textItems[i];
                        const text = textItem.str;

                        // Add to pageTextWithoutSpaces (for matching phrases without spaces)
                        pageTextWithoutSpaces += text;

                        // For pageTextWithSpaces, we need to estimate if there should be a space
                        if (i > 0) {
                            const prevItem = textItems[i - 1];
                            // Estimate if there should be a space between items
                            // If the X distance suggests a gap larger than typical character width, add a space
                            const prevX = prevItem.transform[4];
                            const prevWidth = prevItem.width;
                            const currentX = textItem.transform[4];
                            const charWidth = prevWidth / Math.max(1, prevItem.str.length);

                            // If the distance is more than half a character width, assume a space
                            if (currentX - (prevX + prevWidth) > charWidth * 0.5) {
                                pageTextWithSpaces += ' ';
                            }
                        }

                        pageTextWithSpaces += text;

                        // Store position information for this text item
                        textPositions.push({
                            text: text,
                            transform: textItem.transform,
                            width: textItem.width,
                            height: textItem.height || 15,
                            startIndexWithSpaces: pageTextWithSpaces.length - text.length,
                            endIndexWithSpaces: pageTextWithSpaces.length,
                            startIndexWithoutSpaces: pageTextWithoutSpaces.length - text.length,
                            endIndexWithoutSpaces: pageTextWithoutSpaces.length
                        });
                    }

                    // Helper functions
                    function findMatchingItems(matchStart, matchEnd, textPositions, useWithSpaces) {
                        const matchingItems = [];
                        let currentPos = matchStart;

                        while (currentPos < matchEnd) {
                            // Find the text item that contains the current position
                            const itemIndex = textPositions.findIndex(item => {
                                const startIndex = useWithSpaces ? item.startIndexWithSpaces : item.startIndexWithoutSpaces;
                                const endIndex = useWithSpaces ? item.endIndexWithSpaces : item.endIndexWithoutSpaces;
                                return currentPos >= startIndex && currentPos < endIndex;
                            });

                            if (itemIndex === -1) break;

                            const item = textPositions[itemIndex];
                            const startIndex = useWithSpaces ? item.startIndexWithSpaces : item.startIndexWithoutSpaces;

                            matchingItems.push({
                                item: item,
                                itemIndex: itemIndex,
                                matchStartInItem: Math.max(0, matchStart - startIndex),
                                matchEndInItem: Math.min(item.text.length, matchEnd - startIndex)
                            });

                            // Move to the next text item
                            currentPos = useWithSpaces ? item.endIndexWithSpaces : item.endIndexWithoutSpaces;
                        }

                        return matchingItems;
                    }

                    function createHighlightsForMatch(matchingItems, textPositions, viewport, scale,
                                                      highlightOverlay, pageNum, searchText) {
                        for (const match of matchingItems) {
                            const item = match.item;
                            const matchStartInItem = match.matchStartInItem;
                            const matchEndInItem = match.matchEndInItem;

                            // Calculate the position of the matched portion within the text item
                            const totalWidth = item.width * scale;
                            const charWidth = totalWidth / Math.max(1, item.text.length);
                            const matchedWidth = (matchEndInItem - matchStartInItem) * charWidth;

                            // Calculate starting X position
                            const baseX = item.transform[4] * scale;
                            const offsetX = matchStartInItem * charWidth;
                            const x = baseX + offsetX;

                            // Calculate Y position
                            const textHeight = (item.height || 15) * scale;
                            const y = (viewport.height - item.transform[5]) * scale - textHeight;

                            // Create highlight element
                            const highlightSpan = document.createElement('div');
                            highlightSpan.className = 'highlight';

                            // Adjust position slightly for better visual alignment
                            const adjustedX = x - 2;

                            // Set position and size
                            highlightSpan.style.left = `${adjustedX}px`;
                            highlightSpan.style.top = `${y}px`;
                            highlightSpan.style.width = `${matchedWidth + 4}px`;
                            highlightSpan.style.height = `${textHeight + 3}px`;

                            // Ensure no border or outline
                            highlightSpan.style.border = 'none';
                            highlightSpan.style.outline = 'none';
                            highlightSpan.style.boxShadow = 'none';

                            // Add a title for debugging
                            const matchedText = item.text.substring(matchStartInItem, matchEndInItem);
                            highlightSpan.setAttribute('title', `"${matchedText}" (Page ${pageNum}, part of "${searchText}")`);

                            highlightOverlay.appendChild(highlightSpan);
                        }
                    }

                    // Try matching with spaces first (exact phrase match)
                    const pageTextWithSpacesLower = pageTextWithSpaces.toLowerCase();
                    let searchIndex = 0;

                    while ((searchIndex = pageTextWithSpacesLower.indexOf(searchTextLower, searchIndex)) !== -1) {
                        const matchStart = searchIndex;
                        const matchEnd = searchIndex + searchTextLower.length;

                        window.showDebugMessage(`Found match with spaces at indices ${matchStart}-${matchEnd} on page ${pageNum}`, 'info');

                        // Find which text items contain this match (using with-spaces indices)
                        const matchingItems = findMatchingItems(matchStart, matchEnd, textPositions, true);

                        if (matchingItems.length > 0) {
                            createHighlightsForMatch(matchingItems, textPositions, viewport, scale,
                                                     highlightOverlay, pageNum, searchText);
                            pageHighlights += matchingItems.length;
                            pageMatches++;
                            totalHighlights += matchingItems.length;
                            totalMatches++;
                        }

                        // Move search index forward
                        searchIndex = matchEnd;
                    }

                    // If no matches found with spaces, try matching without spaces
                    // (for cases like "HYPE" at end of line, "LEADER" at start of next line)
                    if (pageMatches === 0) {
                        const pageTextWithoutSpacesLower = pageTextWithoutSpaces.toLowerCase();
                        searchIndex = 0;

                        while ((searchIndex = pageTextWithoutSpacesLower.indexOf(searchTextLowerNoSpaces, searchIndex)) !== -1) {
                            const matchStart = searchIndex;
                            const matchEnd = searchIndex + searchTextLowerNoSpaces.length;

                            window.showDebugMessage(`Found match without spaces at indices ${matchStart}-${matchEnd} on page ${pageNum}`, 'info');

                            // Find which text items contain this match (using without-spaces indices)
                            const matchingItems = findMatchingItems(matchStart, matchEnd, textPositions, false);

                            if (matchingItems.length > 0) {
                                createHighlightsForMatch(matchingItems, textPositions, viewport, scale,
                                                         highlightOverlay, pageNum, searchText);
                                pageHighlights += matchingItems.length;
                                pageMatches++;
                                totalHighlights += matchingItems.length;
                                totalMatches++;
                            }

                            // Move search index forward
                            searchIndex = matchEnd;
                        }
                    }

                    if (pageMatches > 0) {
                        window.showDebugMessage(`Found ${pageMatches} match(es) on page ${pageNum}`, 'info');
                    }

                } catch (error) {
                    window.showDebugMessage(`Error processing page ${pageNum}: ${error.message}`, 'error');
                }
            }

            // Remove loading indicator
            if (loadingIndicator.parentNode) {
                loadingIndicator.parentNode.removeChild(loadingIndicator);
            }

            // NO MODAL WINDOWS - just debug messages
            if (totalMatches > 0) {
                window.showDebugMessage(`SUCCESS: Highlighted "${searchText}" ${totalMatches} time(s) in the PDF`, 'info');
            } else {
                window.showDebugMessage(`No instances of "${searchText}" found (case-insensitive)`, 'info');
            }

            window.showDebugMessage(`FINISHED renderHighlightsForText("${searchText}")`, 'info');
        }

        // --- Real-Time Synchronization (Actor Listener) ---
        function listenForScrollState() {
            if (!currentSessionId || !rtdb) {
                console.error("Cannot listen for scroll state: Session ID or RTDB not initialized.");
                window.showModal('Real-time Error', 'Cannot connect to session. Realtime Database not ready.', true);
                return;
            }

            const viewStateRef = ref(rtdb, `sessions/${currentSessionId}/viewState`);

            onValue(viewStateRef, (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const targetPage = data.page;
                    const targetYPercent = data.y_percent;
                    scrollToPageAndPosition(targetPage, targetYPercent);
                }
            }, (error) => {
                console.error("Error listening to Realtime Database:", error);
                window.showModal('Real-time Error', `Failed to receive real-time updates: ${error.message}`, true);
            });
        }

        // --- Scrolling Logic for Actor App ---
        function scrollToPageAndPosition(pageNumber, yPercent) {
            if (!pdfDoc || !pdfViewerWrapper) return;

            const targetPageDiv = document.getElementById(`page-div-${pageNumber}`); // Target the page wrapper div

            if (targetPageDiv) {
                // Calculate target Y position relative to the start of the page
                const targetScrollY = targetPageDiv.offsetTop + (targetPageDiv.clientHeight * (yPercent / 100));

                pdfViewerWrapper.scrollTo({
                    top: targetScrollY,
                    behavior: 'smooth'
                });
            } else {
                console.warn(`Target page div for page ${pageNumber} not found.`);
            }
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            pdfViewerWrapper = document.getElementById('pdf-viewer-wrapper'); // Our main scrollable div

            // Set up QR modal close button
            document.getElementById('qr-modal-close').onclick = closeQrModal;

            // Set up Show QR button click handler
            document.getElementById('show-qr-btn').onclick = window.handleShowQrClick;

            initializeFirebase();

            // Attach event listener for menu button
            menuButton.addEventListener('click', window.toggleMenu);
            // Close menu if click outside (basic implementation)
            document.addEventListener('click', (event) => {
                if (sideMenu.classList.contains('open') &&
                    !sideMenu.contains(event.target) &&
                    !menuButton.contains(event.target)) {
                    window.toggleMenu();
                }
            });
        });

    </script>
</body>
</html>