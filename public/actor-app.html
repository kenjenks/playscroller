<!DOCTYPE html>
<!-- DANGER! WARNING! THEATER! app for displaying PDF files to follow Stage Manager scrolling -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> <!-- Prevent user zoom -->
    <title>Actor App - PlayScroller</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent body scroll */
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            /* Hide scrollbars for body if they appear, though main scroll is on pdf-viewer-wrapper */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }
        body::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        #pdf-viewer-wrapper {
            position: relative; /* For positioning highlight divs */
            width: 100%;
            height: 100%; /* Take full available space */
            overflow-y: hidden; /* Disable manual scrolling */
            scroll-behavior: smooth; /* Smooth scrolling for programmatic jumps */
            /* Hide scrollbars for pdf-viewer-wrapper too, as SM controls scroll */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }
        #pdf-viewer-wrapper::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        /* Wrapper for each PDF page (canvas + highlight overlay) */
        .pdf-page-wrapper {
            position: relative; /* Crucial for absolute positioning of canvas and overlay */
            margin: 0 auto 8px auto; /* Centered, with bottom margin */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Subtle shadow for visual separation */
            display: block; /* Ensure it takes up full width for centering */
        }

        canvas {
            display: block;
            margin: 0; /* Managed by parent .pdf-page-wrapper */
            position: absolute; /* Positioned within .pdf-page-wrapper */
            top: 0;
            left: 0;
            z-index: 1; /* Ensure canvas is below overlay */
        }

        /* This is the new container for highlights */
        .highlight-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; /* Crucial: ensures it's above the canvas */
            pointer-events: none; /* Allows interaction with elements beneath */
            overflow: hidden; /* Prevent highlights from spilling out */
        }

        /* --- Hamburger Menu Styles --- */
        #menu-button {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 9999px; /* circle */
            padding: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: block; /* Ensure it's block so we can use `display: none` for hiding */
        }
        #menu-button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        #side-menu {
            position: fixed;
            top: 0;
            right: 0;
            width: 250px;
            height: 100%;
            background-color: #fff;
            box-shadow: -4px 0 10px rgba(0,0,0,0.1);
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            z-index: 999;
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }
        #side-menu.open {
            transform: translateX(0);
        }
        #side-menu ul {
            list-style: none;
            padding: 0;
            margin: 1rem 0;
            flex-grow: 1; /* Push close button to bottom if menu items are few */
        }
        #side-menu li {
            margin-bottom: 0.75rem;
        }
        #side-menu button {
            width: 100%;
            padding: 0.75rem;
            background-color: #f3f4f6; /* Light gray */
            border-radius: 0.5rem;
            text-align: left;
            font-size: 1rem;
            color: #1f2937; /* Dark gray */
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #side-menu button:hover {
            background-color: #e5e7eb; /* Lighter gray */
        }

        /* --- Custom highlight styling --- */
        .highlight {
            position: absolute;
            border: none !important;
            border-radius: 2px;
            pointer-events: none; /* Allow interaction with elements beneath */
            z-index: 10;
            mix-blend-mode: multiply; /* Better blending with text */
            /* Ensure no outline or box-shadow */
            outline: none !important;
            box-shadow: none !important;
        }

        /* Highlight color classes */
        .highlight-yellow {
            background-color: rgba(255, 255, 0, 0.4); /* Semi-transparent yellow */
        }
        .highlight-pink {
            background-color: rgba(255, 182, 193, 0.4); /* Semi-transparent pink */
        }
        .highlight-blue {
            background-color: rgba(173, 216, 230, 0.4); /* Semi-transparent blue */
        }
        .highlight-green {
            background-color: rgba(144, 238, 144, 0.4); /* Semi-transparent green */
        }

        /* Color indicator circles */
        .color-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .color-indicator-yellow {
            background-color: rgba(255, 255, 0, 0.8);
        }
        .color-indicator-pink {
            background-color: rgba(255, 182, 193, 0.8);
        }
        .color-indicator-blue {
            background-color: rgba(173, 216, 230, 0.8);
        }
        .color-indicator-green {
            background-color: rgba(144, 238, 144, 0.8);
        }

        /* --- Modal for Highlight Input --- */
        #highlight-modal {
            background-color: rgba(0, 0, 0, 0.7);
        }

        /* Loading indicator for highlight search */
        .highlight-loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 10000;
            display: none;
        }

        /* --- QR Code Modal - Full Screen --- */
        #qr-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        #qr-modal-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            max-width: 1000px;
            text-align: center;
        }

        #qr-code-display {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        #qr-code-display canvas {
            max-width: 90vw;
            max-height: 70vh;
            width: auto !important;
            height: auto !important;
            border: 10px solid white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .qr-title {
            font-size: 2.5rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 1.5rem;
        }

        .qr-instructions {
            font-size: 1.2rem;
            color: #4b5563;
            margin-bottom: 2rem;
            max-width: 600px;
        }

        .session-info {
            background-color: #f3f4f6;
            padding: 15px 25px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 1.1rem;
            margin-bottom: 2rem;
            border: 2px solid #e5e7eb;
        }

        .close-qr-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-qr-btn:hover {
            background-color: rgba(0, 0, 0, 0.9);
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Multi-highlight input styles */
        .highlight-input-group {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
        }

        .highlight-input-header {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .highlight-input-label {
            flex-grow: 1;
            font-size: 0.95rem;
        }

        .highlight-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.95rem;
        }

        .highlight-input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .clear-all-highlights-btn {
            width: 100%;
            margin-top: 1rem;
            padding: 0.75rem;
            background-color: #ef4444;
            color: white;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .clear-all-highlights-btn:hover {
            background-color: #dc2626;
        }

        /* Cookie reminder */
        .cookie-info {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 0.5rem;
            text-align: center;
        }

        /* --- Dark Mode Styles --- */
        body.dark-mode {
            background-color: #121212;
            color: #e0e0e0;
        }

        body.dark-mode #pdf-viewer-wrapper {
            background-color: #1e1e1e;
        }

        body.dark-mode #side-menu {
            background-color: #2d2d2d;
            color: #e0e0e0;
        }

        body.dark-mode #side-menu button {
            background-color: #3d3d3d;
            color: #e0e0e0;
        }

        body.dark-mode #side-menu button:hover {
            background-color: #4d4d4d;
        }

        body.dark-mode #modal .bg-white {
            background-color: #2d2d2d !important;
            color: #e0e0e0;
        }

        body.dark-mode .modal-title,
        body.dark-mode .modal-message,
        body.dark-mode .cookie-info,
        body.dark-mode .highlight-input-label {
            color: #e0e0e0;
        }

        body.dark-mode .highlight-input-group {
            background-color: #3d3d3d;
            border-color: #4d4d4d;
        }

        body.dark-mode .highlight-input {
            background-color: #2d2d2d;
            border-color: #4d4d4d;
            color: #e0e0e0;
        }

        body.dark-mode .highlight-input:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }

        body.dark-mode .clear-all-highlights-btn {
            background-color: #7f1d1d;
        }

        body.dark-mode .clear-all-highlights-btn:hover {
            background-color: #991b1b;
        }

        body.dark-mode #modal-buttons button {
            color: #e0e0e0;
        }

        body.dark-mode #modal-cancel-btn {
            background-color: #4d4d4d;
        }

        body.dark-mode #modal-cancel-btn:hover {
            background-color: #5d5d5d;
        }

        body.dark-mode #modal-ok-btn {
            background-color: #4f46e5;
        }

        body.dark-mode #modal-ok-btn:hover {
            background-color: #4338ca;
        }
    </style>
    <!-- PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js"></script> <!-- Worker also needed -->
    <!-- QRious for QR code generation -->
    <script src="https://unpkg.com/qrious@4.0.2/dist/qrious.min.js"></script>
</head>
<body class="p-0"> <!-- Remove default padding -->

    <!-- Main Content Area - PDF Viewer -->
    <div id="pdf-viewer-wrapper">
        <!-- PDF Canvases and highlight divs will be rendered here -->
        <p id="loading-message" class="text-center py-12 text-gray-500 text-lg">Connecting to session and loading PDF...</p>
    </div>

    <!-- Hamburger Menu Button -->
    <button id="menu-button">
        <!-- Hamburger Icon (SVG for crispness) -->
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
    </button>

    <!-- Side Menu Panel -->
    <div id="side-menu">
        <button class="self-end p-2 bg-transparent text-gray-500 hover:text-gray-800" onclick="window.toggleMenu()">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
        </button>
        <ul>
            <li><button id="highlight-menu-item" onclick="window.handleHighlightClick()">Highlight Text...</button></li>
            <li><button id="toggle-dark-mode-btn" onclick="window.toggleDarkMode()">Toggle Dark Mode</button></li>
            <li><button id="show-qr-btn" class="hidden">Show Session QR Code</button></li>
            <li><button id="exit-menu-item" onclick="window.exitApp()">Exit</button></li>
        </ul>
    </div>

    <!-- Generic Modal for Highlight Input / Errors -->
    <div id="modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-md w-full">
            <h3 id="modal-title" class="text-xl font-bold mb-4 text-gray-800">Multi-Color Text Highlight</h3>
            <p id="modal-message" class="text-gray-700 mb-6">Enter text to highlight in different colors. Clear a field to remove highlights of that color.</p>

            <!-- Multi-color highlight inputs -->
            <div id="highlight-inputs-container">
                <!-- Yellow highlight input -->
                <div class="highlight-input-group" data-color="yellow">
                    <div class="highlight-input-header">
                        <span class="color-indicator color-indicator-yellow"></span>
                        <span class="highlight-input-label">Yellow Highlight</span>
                    </div>
                    <input type="text"
                           class="highlight-input yellow-highlight-input"
                           placeholder="Enter text for yellow highlight"
                           data-color="yellow">
                </div>

                <!-- Pink highlight input -->
                <div class="highlight-input-group" data-color="pink">
                    <div class="highlight-input-header">
                        <span class="color-indicator color-indicator-pink"></span>
                        <span class="highlight-input-label">Pink Highlight</span>
                    </div>
                    <input type="text"
                           class="highlight-input pink-highlight-input"
                           placeholder="Enter text for pink highlight"
                           data-color="pink">
                </div>

                <!-- Blue highlight input -->
                <div class="highlight-input-group" data-color="blue">
                    <div class="highlight-input-header">
                        <span class="color-indicator color-indicator-blue"></span>
                        <span class="highlight-input-label">Blue Highlight</span>
                    </div>
                    <input type="text"
                           class="highlight-input blue-highlight-input"
                           placeholder="Enter text for blue highlight"
                           data-color="blue">
                </div>

                <!-- Green highlight input -->
                <div class="highlight-input-group" data-color="green">
                    <div class="highlight-input-header">
                        <span class="color-indicator color-indicator-green"></span>
                        <span class="highlight-input-label">Green Highlight</span>
                    </div>
                    <input type="text"
                           class="highlight-input green-highlight-input"
                           placeholder="Enter text for green highlight"
                           data-color="green">
                </div>
            </div>

            <!-- Cookie info -->
            <p class="cookie-info">Your highlight preferences will be saved for future sessions</p>

            <!-- Clear All Highlights Button -->
            <button id="clear-all-highlights-btn" class="clear-all-highlights-btn">
                Clear All Highlights
            </button>

            <div id="modal-buttons" class="flex justify-end space-x-4 mt-6">
                <button id="modal-cancel-btn" class="py-2 px-4 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">Cancel</button>
                <button id="modal-ok-btn" class="py-2 px-4 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">Apply Highlights</button>
            </div>
        </div>
    </div>

    <!-- Modal for QR Code Display - FULL SCREEN -->
    <div id="qr-modal" class="hidden">
        <button class="close-qr-btn" id="qr-modal-close">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
        </button>
        <div id="qr-modal-content">
            <h2 class="qr-title">Session QR Code</h2>
            <p class="qr-instructions">Scan this QR code to join the same session</p>
            <div id="qr-code-display">
                <!-- QR code will be rendered here -->
            </div>
            <div class="session-info">
                Session ID: <span id="session-id-display"></span>
            </div>
        </div>
    </div>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getDatabase, ref, onValue } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // --- Global Firebase Variables ---
        const firebaseConfig = {
          apiKey: "AIzaSyBG9pzEdllxWnZu0zYQMXqEFzJWNAVv6Lw",
          authDomain: "playscroller.firebaseapp.com",
          projectId: "playscroller",
          storageBucket: "playscroller.appspot.com",
          messagingSenderId: "86147104940",
          appId: "1:86147104940:web:f1bd908e1206795f9d1f09"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);

        let rtdb, auth, userId;
        let pdfDoc = null;
        let pdfViewerWrapper; // Our main scrollable div
        let currentSessionId = null;
        let currentPdfUrl = null;

        // Store active highlight texts for each color
        let activeHighlightTexts = {
            yellow: "",
            pink: "",
            blue: "",
            green: ""
        };

        // Cookie management functions
        const COOKIE_NAME = 'playscroller_highlights';
        const COOKIE_EXPIRY_DAYS = 30;

        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + encodeURIComponent(value) + expires + "; path=/; SameSite=Lax";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) {
                    return decodeURIComponent(c.substring(nameEQ.length, c.length));
                }
            }
            return null;
        }

        function deleteCookie(name) {
            setCookie(name, "", -1);
        }

        function saveHighlightsToCookie() {
            try {
                const highlightsData = JSON.stringify(activeHighlightTexts);
                setCookie(COOKIE_NAME, highlightsData, COOKIE_EXPIRY_DAYS);
                console.log('Highlights saved to cookie:', activeHighlightTexts);
            } catch (error) {
                console.error('Error saving highlights to cookie:', error);
            }
        }

        function loadHighlightsFromCookie() {
            try {
                const cookieData = getCookie(COOKIE_NAME);
                if (cookieData) {
                    const parsedData = JSON.parse(cookieData);

                    // Validate the parsed data has all required colors
                    if (parsedData && typeof parsedData === 'object') {
                        // Ensure all color keys exist
                        const defaultHighlights = {
                            yellow: "",
                            pink: "",
                            blue: "",
                            green: ""
                        };

                        activeHighlightTexts = { ...defaultHighlights, ...parsedData };
                        console.log('Highlights loaded from cookie:', activeHighlightTexts);

                        // Apply loaded highlights if PDF is already loaded
                        if (pdfDoc) {
                            applyHighlightsFromStorage();
                        }

                        return true;
                    }
                }
            } catch (error) {
                console.error('Error loading highlights from cookie:', error);
                // If cookie is corrupted, delete it
                deleteCookie(COOKIE_NAME);
            }
            return false;
        }

        async function applyHighlightsFromStorage() {
            console.log('Applying highlights from storage:', activeHighlightTexts);

            // Apply highlights for each color that has text
            for (const [color, text] of Object.entries(activeHighlightTexts)) {
                if (text && text.trim() !== "") {
                    console.log(`Applying saved highlight for ${color}: "${text}"`);
                    await renderHighlightsForText(text, color);
                }
            }
        }

        // Ensure PDF.js worker is set up
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        // Simple logging function (kept for internal use but no debug UI)
        window.showDebugMessage = (message, type = 'info') => {
            const timestamp = new Date().toLocaleTimeString();
            const formattedMessage = `[${timestamp}] ${message}`;
            // Just log to console instead of showing in UI
            if (type === 'error') {
                console.error(formattedMessage);
            } else {
                console.log(formattedMessage);
            }
        };

        // --- Dark Mode Functions ---
        function initializeDarkMode() {
            // Check for saved dark mode preference or prefer-color-scheme
            const savedMode = localStorage.getItem('playscroller_dark_mode');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Apply dark mode if saved preference is true, or if no preference but system prefers dark
            const shouldEnable = savedMode === 'true' || (!savedMode && prefersDark);

            if (shouldEnable) {
                document.body.classList.add('dark-mode');
                updateDarkModeButton(true);
            } else {
                document.body.classList.remove('dark-mode');
                updateDarkModeButton(false);
            }
        }

        function toggleDarkMode() {
            const isDark = document.body.classList.toggle('dark-mode');

            // Save preference to localStorage
            localStorage.setItem('playscroller_dark_mode', isDark.toString());

            // Update button text
            updateDarkModeButton(isDark);

            // Close menu
            window.toggleMenu();

            // Log for debugging
            window.showDebugMessage(`Dark Mode ${isDark ? 'enabled' : 'disabled'}`, 'info');
        }

        function updateDarkModeButton(isDark) {
            const button = document.getElementById('toggle-dark-mode-btn');
            if (button) {
                button.textContent = isDark ? 'Toggle Light Mode' : 'Toggle Dark Mode';
            }
        }

        // --- UI Utility Functions ---
        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const highlightInputsContainer = document.getElementById('highlight-inputs-container');
        const clearAllHighlightsBtn = document.getElementById('clear-all-highlights-btn');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        window.showModal = (title, message, isError = true, showInput = false, onOk = null, onCancel = null) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalTitle.className = isError ? 'text-xl font-bold mb-4 text-red-600' : 'text-xl font-bold mb-4 text-green-600';

            if (showInput) {
                highlightInputsContainer.style.display = 'block';
                clearAllHighlightsBtn.style.display = 'block';

                // Pre-fill inputs with current highlight texts (from memory)
                document.querySelector('.yellow-highlight-input').value = activeHighlightTexts.yellow;
                document.querySelector('.pink-highlight-input').value = activeHighlightTexts.pink;
                document.querySelector('.blue-highlight-input').value = activeHighlightTexts.blue;
                document.querySelector('.green-highlight-input').value = activeHighlightTexts.green;

                modalCancelBtn.classList.remove('hidden');
                modalOkBtn.textContent = 'Apply Highlights';

                // Set up button handlers
                modalOkBtn.onclick = async () => {
                    // Get all input values
                    const inputs = {
                        yellow: document.querySelector('.yellow-highlight-input').value,
                        pink: document.querySelector('.pink-highlight-input').value,
                        blue: document.querySelector('.blue-highlight-input').value,
                        green: document.querySelector('.green-highlight-input').value
                    };

                    // Disable the OK button while processing
                    modalOkBtn.disabled = true;
                    modalOkBtn.textContent = 'Processing...';
                    modalOkBtn.classList.add('opacity-50', 'cursor-not-allowed');

                    try {
                        // Process each color separately
                        for (const [color, text] of Object.entries(inputs)) {
                            const cleanedText = cleanSearchText(text);

                            if (cleanedText === "" && activeHighlightTexts[color] !== "") {
                                // Text changed from non-blank to blank - remove this color's highlights
                                window.showDebugMessage(`Clearing ${color} highlights (blank input)`, 'info');
                                removeHighlightsByColor(color);
                                activeHighlightTexts[color] = "";
                            } else if (cleanedText !== "" && cleanedText !== activeHighlightTexts[color]) {
                                // Text changed to non-blank and is different - update highlights
                                activeHighlightTexts[color] = cleanedText;
                                await renderHighlightsForText(cleanedText, color);
                            }
                            // If text is same as before, do nothing
                        }

                        // Save to cookie after processing all colors
                        saveHighlightsToCookie();

                    } finally {
                        // Always close the modal after callback completes
                        window.closeModal();
                    }
                };

                modalCancelBtn.onclick = () => {
                    if (onCancel) {
                        onCancel();
                    }
                    window.closeModal();
                };

                // Focus the first input field
                setTimeout(() => {
                    document.querySelector('.yellow-highlight-input').focus();
                }, 100);
            } else {
                highlightInputsContainer.style.display = 'none';
                clearAllHighlightsBtn.style.display = 'none';
                modalCancelBtn.classList.remove('hidden');
                modalOkBtn.textContent = 'OK';

                // For non-input modals, use simple close
                modalOkBtn.onclick = window.closeModal;
                modalCancelBtn.onclick = window.closeModal;
            }

            modal.classList.remove('hidden');
        };

        window.closeModal = () => {
            modal.classList.add('hidden');
            // Reset OK button state
            modalOkBtn.disabled = false;
            modalOkBtn.textContent = 'Apply Highlights';
            modalOkBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        };

        // Function to remove highlights by color
        function removeHighlightsByColor(color) {
            const highlights = document.querySelectorAll(`.highlight-${color}`);
            window.showDebugMessage(`Removing ${highlights.length} ${color} highlights`, 'info');
            highlights.forEach(el => el.remove());
        }

        // Function to clear all highlights
        function clearAllHighlights() {
            window.showDebugMessage("Clearing ALL highlights", 'info');

            // Remove all highlights
            document.querySelectorAll('.highlight').forEach(el => el.remove());

            // Clear all active highlight texts
            activeHighlightTexts = {
                yellow: "",
                pink: "",
                blue: "",
                green: ""
            };

            // Clear all input fields
            document.querySelectorAll('.highlight-input').forEach(input => {
                input.value = "";
            });

            // Delete the cookie
            deleteCookie(COOKIE_NAME);

            // Close modal after clearing
            window.closeModal();
        }

        // --- QR Code Modal Functions ---
        function showQrModal() {
            if (!currentSessionId || !currentPdfUrl) {
                window.showModal('No Session', 'Not connected to a session yet.', true);
                return;
            }

            // Generate the actor app URL (same as current page URL)
            const actorAppUrl = window.location.origin + window.location.pathname;
            const actorSyncUrl = `${actorAppUrl}?session_id=${currentSessionId}&pdf_url=${encodeURIComponent(currentPdfUrl)}`;

            window.showDebugMessage(`QR Code URL: ${actorSyncUrl}`, 'info');

            // Update session ID display
            document.getElementById('session-id-display').textContent = currentSessionId;

            // Generate QR code - make it as large as possible
            const qrDisplay = document.getElementById('qr-code-display');
            qrDisplay.innerHTML = '';

            // Create container for QR code
            const qrContainer = document.createElement('div');
            qrContainer.style.width = '100%';
            qrContainer.style.height = '100%';
            qrContainer.style.display = 'flex';
            qrContainer.style.justifyContent = 'center';
            qrContainer.style.alignItems = 'center';

            const qrCanvas = document.createElement('canvas');
            qrContainer.appendChild(qrCanvas);
            qrDisplay.appendChild(qrContainer);

            // Calculate optimal size based on screen dimensions
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const qrSize = Math.min(screenWidth, screenHeight) * 0.8;

            new QRious({
                element: qrCanvas,
                value: actorSyncUrl,
                size: qrSize,
                background: '#ffffff',
                foreground: '#000000', // Black for maximum contrast
                level: 'H' // Highest error correction
            });

            document.getElementById('qr-modal').classList.remove('hidden');

            // Hide menu button when QR code is shown
            document.getElementById('menu-button').classList.add('hidden');
        }

        function closeQrModal() {
            document.getElementById('qr-modal').classList.add('hidden');

            // Show menu button again
            document.getElementById('menu-button').classList.remove('hidden');
        }

        // --- Menu Functions ---
        const menuButton = document.getElementById('menu-button');
        const sideMenu = document.getElementById('side-menu');

        window.toggleMenu = () => {
            sideMenu.classList.toggle('open');
            // Hide menu button when side menu is open, show when closed
            menuButton.style.display = sideMenu.classList.contains('open') ? 'none' : 'block';
        };

        // Helper function to clean search text
        function cleanSearchText(text) {
            // Remove spaces from the beginning and end
            let cleaned = text.trim();
            window.showDebugMessage(`Cleaned search text: "${text}" -> "${cleaned}"`, 'info');
            return cleaned;
        }

        window.handleHighlightClick = () => {
            window.toggleMenu(); // Close the side menu
            window.showModal('Multi-Color Text Highlight',
                'Enter text to highlight in different colors. Clear a field to remove highlights of that color.',
                false, true,
                null, // onOk handled in showModal
                () => {
                    window.showDebugMessage("Highlight cancelled", 'info');
                }
            );
        };

        // Function to handle Show QR Code button click
        window.handleShowQrClick = () => {
            window.toggleMenu(); // Close the side menu
            showQrModal();
        };

        window.exitApp = () => {
            if (window.opener) {
                window.close(); // Try to close the current tab/window
            } else {
                // If it's the main window, simply show a message or redirect.
                // Cannot force close window not opened by script.
                window.showModal('Exit App', 'You can close this tab/window manually.', false);
            }
        };

        // --- Core App Initialization ---
        async function initializeFirebase() {
            try {
                if (!firebaseConfig.apiKey || Object.keys(firebaseConfig).length === 0) {
                     window.showModal('Configuration Error', 'Firebase API Key is missing or Firebase configuration is empty. Cannot initialize.', true);
                     return;
                }

                rtdb = getDatabase(app);
                auth = getAuth(app);

                await signInAnonymously(auth);
                userId = auth.currentUser?.uid || crypto.randomUUID();
                window.showDebugMessage("Actor User ID: " + userId, 'info');

                // Load highlights from cookie BEFORE extracting session parameters
                loadHighlightsFromCookie();

                // Extract session_id and pdf_url from QR code URL
                const urlParams = new URLSearchParams(window.location.search);
                const sessionIdFromUrl = urlParams.get('session_id');
                const pdfUrlFromUrl = urlParams.get('pdf_url');

                if (!sessionIdFromUrl || !pdfUrlFromUrl) {
                    window.showModal('Connection Error', 'Missing Session ID or PDF URL in QR code link. Please scan the Stage Manager\'s QR code.', true);
                    document.getElementById('loading-message').textContent = 'Error: Missing session details.';
                    return;
                }

                currentSessionId = sessionIdFromUrl;
                currentPdfUrl = pdfUrlFromUrl;
                window.showDebugMessage(`Connected to Session: ${currentSessionId}, PDF URL: ${currentPdfUrl}`, 'info');

                // Show QR button now that we have session info
                document.getElementById('show-qr-btn').classList.remove('hidden');

                document.getElementById('loading-message').textContent = `Connected to session ${currentSessionId}. Loading PDF...`;

                // Load and render PDF first
                await loadAndRenderPDF(currentPdfUrl);

                // Start listening for scroll state changes
                listenForScrollState();

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                window.showModal('Initialization Failed', `Could not initialize Firebase: ${error.message}`, true);
                document.getElementById('loading-message').textContent = 'Error: Firebase initialization failed.';
            }
        }

        // --- PDF Rendering Functions ---
        async function renderPage(pageNumber, pdfPage) {
            // Scale to fit width of the viewer wrapper (which is 100vw)
            const scale = pdfViewerWrapper.clientWidth / pdfPage.getViewport({ scale: 1 }).width;
            const viewport = pdfPage.getViewport({ scale: scale });

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            canvas.id = `pdf-page-${pageNumber}`;
            canvas.setAttribute('data-page', pageNumber);
            // No absolute positioning here, will be handled by parent for full width

            const pageDiv = document.createElement('div');
            pageDiv.id = `page-div-${pageNumber}`;
            pageDiv.classList.add('pdf-page-wrapper'); // Add this class for consistent styling
            pageDiv.style.width = `${viewport.width}px`; // Explicit width to ensure centering and context
            pageDiv.style.height = `${viewport.height}px`; // Explicit height

            // Create the highlight overlay
            const highlightOverlay = document.createElement('div');
            highlightOverlay.className = 'highlight-overlay';
            highlightOverlay.id = `highlight-overlay-${pageNumber}`; // Give it an ID for targeting

            window.showDebugMessage(`Created overlay for page ${pageNumber}: ${highlightOverlay.id}`, 'info');

            pageDiv.appendChild(canvas);
            pageDiv.appendChild(highlightOverlay); // Append overlay AFTER canvas for z-index
            pdfViewerWrapper.appendChild(pageDiv);

            await pdfPage.render({ canvasContext: context, viewport: viewport }).promise;

            // Store text content and viewport for later highlighting
            const textContent = await pdfPage.getTextContent();
            pdfPage.textContentItems = textContent.items; // Attach for later use
            pdfPage.viewport = viewport; // Also store viewport for highlight positioning
        }

        async function loadAndRenderPDF(pdfUrl) {
            pdfViewerWrapper.innerHTML = '<p id="loading-message" class="text-center py-12 text-gray-500 text-lg">Loading PDF, please wait...</p>';
            try {
                const pdf = await pdfjsLib.getDocument(pdfUrl).promise;
                pdfDoc = pdf;
                pdfViewerWrapper.innerHTML = ''; // Clear loading message

                window.showDebugMessage(`PDF loaded: ${pdf.numPages} pages`, 'info');

                // Render all pages
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    await renderPage(i, page);
                }

                // Initial scroll to top
                pdfViewerWrapper.scrollTop = 0;

                // Apply saved highlights after PDF is loaded
                applyHighlightsFromStorage();

            } catch (error) {
                console.error("PDF Loading Error:", error);
                window.showModal('PDF Loading Error', `Could not load PDF from URL. Check the URL and CORS settings. ${error.message}`, true);
                pdfViewerWrapper.innerHTML = '<p id="loading-message" class="text-center py-12 text-gray-500 text-lg">PDF loading failed.</p>';
                pdfDoc = null; // Reset document
            }
        }

        // --- Highlighting Logic ---
        async function renderHighlightsForText(searchText, color) {
            window.showDebugMessage(`STARTING renderHighlightsForText("${searchText}", "${color}")`, 'info');

            // Clear existing highlights of this color only
            const existingHighlights = document.querySelectorAll(`.highlight-${color}`).length;
            window.showDebugMessage(`Clearing ${existingHighlights} existing ${color} highlights`, 'info');
            document.querySelectorAll(`.highlight-${color}`).forEach(el => el.remove());

            // Show loading indicator
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'highlight-loading';
            loadingIndicator.textContent = `Searching for "${searchText}" (${color})...`;
            loadingIndicator.style.display = 'block';
            document.body.appendChild(loadingIndicator);

            window.showDebugMessage(`Searching for "${searchText}" in PDF (case-insensitive, color: ${color})...`, 'info');

            if (!pdfDoc) {
                window.showDebugMessage("ERROR: No PDF document loaded", 'error');
                if (loadingIndicator.parentNode) {
                    loadingIndicator.parentNode.removeChild(loadingIndicator);
                }
                return;
            }

            // Prepare search text: case-insensitive and trim only
            const searchTextLower = searchText.toLowerCase().trim();
            const searchTextLowerNoSpaces = searchTextLower.replace(/\s+/g, ''); // For matching without spaces
            let totalHighlights = 0;
            let totalMatches = 0;

            // Search through all pages
            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                try {
                    window.showDebugMessage(`Processing page ${pageNum} for ${color}...`, 'info');
                    const page = await pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();

                    // Get the highlight overlay for this page
                    const highlightOverlay = document.getElementById(`highlight-overlay-${pageNum}`);
                    if (!highlightOverlay) {
                        window.showDebugMessage(`No overlay for page ${pageNum}`, 'error');
                        continue;
                    }

                    // Get the canvas to match dimensions
                    const canvas = document.getElementById(`pdf-page-${pageNum}`);
                    if (!canvas) {
                        window.showDebugMessage(`No canvas for page ${pageNum}`, 'error');
                        continue;
                    }

                    // Get the viewport and scale
                    const viewport = page.getViewport({ scale: 1 });
                    const scale = canvas.width / viewport.width;

                    let pageHighlights = 0;
                    let pageMatches = 0;

                    // Build concatenated text from all text items on this page WITH estimated spaces
                    let pageTextWithSpaces = '';
                    let pageTextWithoutSpaces = '';
                    const textItems = textContent.items;

                    // Create a mapping of text positions
                    const textPositions = [];

                    // First pass: build the full page text and track positions
                    for (let i = 0; i < textItems.length; i++) {
                        const textItem = textItems[i];
                        const text = textItem.str;

                        // Add to pageTextWithoutSpaces (for matching phrases without spaces)
                        pageTextWithoutSpaces += text;

                        // For pageTextWithSpaces, we need to estimate if there should be a space
                        if (i > 0) {
                            const prevItem = textItems[i - 1];
                            // Estimate if there should be a space between items
                            // If the X distance suggests a gap larger than typical character width, add a space
                            const prevX = prevItem.transform[4];
                            const prevWidth = prevItem.width;
                            const currentX = textItem.transform[4];
                            const charWidth = prevWidth / Math.max(1, prevItem.str.length);

                            // If the distance is more than half a character width, assume a space
                            if (currentX - (prevX + prevWidth) > charWidth * 0.5) {
                                pageTextWithSpaces += ' ';
                            }
                        }

                        pageTextWithSpaces += text;

                        // Store position information for this text item
                        textPositions.push({
                            text: text,
                            transform: textItem.transform,
                            width: textItem.width,
                            height: textItem.height || 15,
                            startIndexWithSpaces: pageTextWithSpaces.length - text.length,
                            endIndexWithSpaces: pageTextWithSpaces.length,
                            startIndexWithoutSpaces: pageTextWithoutSpaces.length - text.length,
                            endIndexWithoutSpaces: pageTextWithoutSpaces.length
                        });
                    }

                    // Helper functions
                    function findMatchingItems(matchStart, matchEnd, textPositions, useWithSpaces) {
                        const matchingItems = [];
                        let currentPos = matchStart;

                        while (currentPos < matchEnd) {
                            // Find the text item that contains the current position
                            const itemIndex = textPositions.findIndex(item => {
                                const startIndex = useWithSpaces ? item.startIndexWithSpaces : item.startIndexWithoutSpaces;
                                const endIndex = useWithSpaces ? item.endIndexWithSpaces : item.endIndexWithoutSpaces;
                                return currentPos >= startIndex && currentPos < endIndex;
                            });

                            if (itemIndex === -1) break;

                            const item = textPositions[itemIndex];
                            const startIndex = useWithSpaces ? item.startIndexWithSpaces : item.endIndexWithoutSpaces;

                            matchingItems.push({
                                item: item,
                                itemIndex: itemIndex,
                                matchStartInItem: Math.max(0, matchStart - startIndex),
                                matchEndInItem: Math.min(item.text.length, matchEnd - startIndex)
                            });

                            // Move to the next text item
                            currentPos = useWithSpaces ? item.endIndexWithSpaces : item.endIndexWithoutSpaces;
                        }

                        return matchingItems;
                    }

                    function createHighlightsForMatch(matchingItems, textPositions, viewport, scale,
                                                      highlightOverlay, pageNum, searchText, color) {
                        for (const match of matchingItems) {
                            const item = match.item;
                            const matchStartInItem = match.matchStartInItem;
                            const matchEndInItem = match.matchEndInItem;

                            // Calculate the position of the matched portion within the text item
                            const totalWidth = item.width * scale;
                            const charWidth = totalWidth / Math.max(1, item.text.length);
                            const matchedWidth = (matchEndInItem - matchStartInItem) * charWidth;

                            // Calculate starting X position
                            const baseX = item.transform[4] * scale;
                            const offsetX = matchStartInItem * charWidth;
                            const x = baseX + offsetX;

                            // Calculate Y position
                            const textHeight = (item.height || 15) * scale;
                            const y = (viewport.height - item.transform[5]) * scale - textHeight;

                            // Create highlight element
                            const highlightSpan = document.createElement('div');
                            highlightSpan.className = `highlight highlight-${color}`;

                            // Adjust position slightly for better visual alignment
                            const adjustedX = x - 2;

                            // Set position and size
                            highlightSpan.style.left = `${adjustedX}px`;
                            highlightSpan.style.top = `${y}px`;
                            highlightSpan.style.width = `${matchedWidth + 4}px`;
                            highlightSpan.style.height = `${textHeight + 3}px`;

                            // Ensure no border or outline
                            highlightSpan.style.border = 'none';
                            highlightSpan.style.outline = 'none';
                            highlightSpan.style.boxShadow = 'none';

                            // Add a title for debugging
                            const matchedText = item.text.substring(matchStartInItem, matchEndInItem);
                            highlightSpan.setAttribute('title', `"${matchedText}" (Page ${pageNum}, color: ${color}, part of "${searchText}")`);

                            highlightOverlay.appendChild(highlightSpan);
                        }
                    }

                    // Try matching with spaces first (exact phrase match)
                    const pageTextWithSpacesLower = pageTextWithSpaces.toLowerCase();
                    let searchIndex = 0;

                    while ((searchIndex = pageTextWithSpacesLower.indexOf(searchTextLower, searchIndex)) !== -1) {
                        const matchStart = searchIndex;
                        const matchEnd = searchIndex + searchTextLower.length;

                        window.showDebugMessage(`Found ${color} match with spaces at indices ${matchStart}-${matchEnd} on page ${pageNum}`, 'info');

                        // Find which text items contain this match (using with-spaces indices)
                        const matchingItems = findMatchingItems(matchStart, matchEnd, textPositions, true);

                        if (matchingItems.length > 0) {
                            createHighlightsForMatch(matchingItems, textPositions, viewport, scale,
                                                     highlightOverlay, pageNum, searchText, color);
                            pageHighlights += matchingItems.length;
                            pageMatches++;
                            totalHighlights += matchingItems.length;
                            totalMatches++;
                        }

                        // Move search index forward
                        searchIndex = matchEnd;
                    }

                    // If no matches found with spaces, try matching without spaces
                    // (for cases like "HYPE" at end of line, "LEADER" at start of next line)
                    if (pageMatches === 0) {
                        const pageTextWithoutSpacesLower = pageTextWithoutSpaces.toLowerCase();
                        searchIndex = 0;

                        while ((searchIndex = pageTextWithoutSpacesLower.indexOf(searchTextLowerNoSpaces, searchIndex)) !== -1) {
                            const matchStart = searchIndex;
                            const matchEnd = searchIndex + searchTextLowerNoSpaces.length;

                            window.showDebugMessage(`Found ${color} match without spaces at indices ${matchStart}-${matchEnd} on page ${pageNum}`, 'info');

                            // Find which text items contain this match (using without-spaces indices)
                            const matchingItems = findMatchingItems(matchStart, matchEnd, textPositions, false);

                            if (matchingItems.length > 0) {
                                createHighlightsForMatch(matchingItems, textPositions, viewport, scale,
                                                         highlightOverlay, pageNum, searchText, color);
                                pageHighlights += matchingItems.length;
                                pageMatches++;
                                totalHighlights += matchingItems.length;
                                totalMatches++;
                            }

                            // Move search index forward
                            searchIndex = matchEnd;
                        }
                    }

                    if (pageMatches > 0) {
                        window.showDebugMessage(`Found ${pageMatches} ${color} match(es) on page ${pageNum}`, 'info');
                    }

                } catch (error) {
                    window.showDebugMessage(`Error processing page ${pageNum} for ${color}: ${error.message}`, 'error');
                }
            }

            // Remove loading indicator
            if (loadingIndicator.parentNode) {
                loadingIndicator.parentNode.removeChild(loadingIndicator);
            }

            // NO MODAL WINDOWS - just debug messages
            if (totalMatches > 0) {
                window.showDebugMessage(`SUCCESS: Highlighted "${searchText}" ${totalMatches} time(s) in the PDF with ${color} color`, 'info');
            } else {
                window.showDebugMessage(`No instances of "${searchText}" found for ${color} highlight (case-insensitive)`, 'info');
            }

            window.showDebugMessage(`FINISHED renderHighlightsForText("${searchText}", "${color}")`, 'info');
        }

        // --- Real-Time Synchronization (Actor Listener) ---
        function listenForScrollState() {
            if (!currentSessionId || !rtdb) {
                console.error("Cannot listen for scroll state: Session ID or RTDB not initialized.");
                window.showModal('Real-time Error', 'Cannot connect to session. Realtime Database not ready.', true);
                return;
            }

            const viewStateRef = ref(rtdb, `sessions/${currentSessionId}/viewState`);

            onValue(viewStateRef, (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const targetPage = data.page;
                    const targetYPercent = data.y_percent;
                    scrollToPageAndPosition(targetPage, targetYPercent);
                }
            }, (error) => {
                console.error("Error listening to Realtime Database:", error);
                window.showModal('Real-time Error', `Failed to receive real-time updates: ${error.message}`, true);
            });
        }

        // --- Scrolling Logic for Actor App ---
        function scrollToPageAndPosition(pageNumber, yPercent) {
            if (!pdfDoc || !pdfViewerWrapper) return;

            const targetPageDiv = document.getElementById(`page-div-${pageNumber}`); // Target the page wrapper div

            if (targetPageDiv) {
                // Calculate target Y position relative to the start of the page
                const targetScrollY = targetPageDiv.offsetTop + (targetPageDiv.clientHeight * (yPercent / 100));

                pdfViewerWrapper.scrollTo({
                    top: targetScrollY,
                    behavior: 'smooth'
                });
            } else {
                console.warn(`Target page div for page ${pageNumber} not found.`);
            }
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            pdfViewerWrapper = document.getElementById('pdf-viewer-wrapper');

            // Initialize dark mode
            initializeDarkMode();

            // Set up QR modal close button
            document.getElementById('qr-modal-close').onclick = closeQrModal;

            // Set up Show QR button click handler
            document.getElementById('show-qr-btn').onclick = window.handleShowQrClick;

            // Set up Clear All Highlights button
            clearAllHighlightsBtn.onclick = clearAllHighlights;

            initializeFirebase();

            // Attach event listener for menu button
            menuButton.addEventListener('click', window.toggleMenu);
            // Close menu if click outside (basic implementation)
            document.addEventListener('click', (event) => {
                if (sideMenu.classList.contains('open') &&
                    !sideMenu.contains(event.target) &&
                    !menuButton.contains(event.target)) {
                    window.toggleMenu();
                }
            });
        });

    </script>
</body>
</html>