<!DOCTYPE html>
<!-- DANGER! WARNING! THEATER! app for displaying PDF files on actors' devices -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stage Manager App (SM)</title>
    <!-- Tailwind CSS for mobile-first, responsive design -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        /* Full-screen PDF container */
        #pdf-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow-y: scroll;
            background-color: white;
            z-index: 1;
        }
        canvas {
            display: block;
            margin: 0 auto;
        }
        /* Custom scrollbar */
        #pdf-container::-webkit-scrollbar {
            width: 8px;
        }
        #pdf-container::-webkit-scrollbar-thumb {
            background-color: #94a3b8;
            border-radius: 10px;
        }

        /* --- Hamburger Menu Styles --- */
        #menu-button {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 9999px;
            padding: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: block;
        }
        #menu-button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        #side-menu {
            position: fixed;
            top: 0;
            right: 0;
            width: 250px;
            height: 100%;
            background-color: #fff;
            box-shadow: -4px 0 10px rgba(0,0,0,0.1);
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            z-index: 999;
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }
        #side-menu.open {
            transform: translateX(0);
        }
        #side-menu ul {
            list-style: none;
            padding: 0;
            margin: 1rem 0;
            flex-grow: 1;
        }
        #side-menu li {
            margin-bottom: 0.75rem;
        }
        #side-menu button {
            width: 100%;
            padding: 0.75rem;
            background-color: #f3f4f6;
            border-radius: 0.5rem;
            text-align: left;
            font-size: 1rem;
            color: #1f2937;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #side-menu button:hover {
            background-color: #e5e7eb;
        }

        /* Welcome screen */
        #welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #f7f7f7;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 2rem;
        }

        /* QR Code display in modal - FULL SCREEN */
        #qr-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        #qr-modal-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            max-width: 1000px;
            text-align: center;
        }

        #qr-code-display {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        #qr-code-display canvas {
            max-width: 90vw;
            max-height: 70vh;
            width: auto !important;
            height: auto !important;
            border: 10px solid white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .qr-title {
            font-size: 2.5rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 1.5rem;
        }

        .qr-instructions {
            font-size: 1.2rem;
            color: #4b5563;
            margin-bottom: 2rem;
            max-width: 600px;
        }

        .session-info {
            background-color: #f3f4f6;
            padding: 15px 25px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 1.1rem;
            margin-bottom: 2rem;
            border: 2px solid #e5e7eb;
        }

        .close-qr-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-qr-btn:hover {
            background-color: rgba(0, 0, 0, 0.9);
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Status indicator */
        #status-indicator {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 1000;
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal-content {
            background: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #1f2937;
        }

        .modal-message {
            margin-bottom: 1.5rem;
            color: #4b5563;
        }

        .modal-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            margin-bottom: 1.5rem;
            font-size: 1rem;
        }

        .modal-input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        .modal-button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }

        .modal-button-primary {
            background-color: #4f46e5;
            color: white;
        }

        .modal-button-primary:hover {
            background-color: #4338ca;
        }

        .modal-button-secondary {
            background-color: #e5e7eb;
            color: #374151;
        }

        .modal-button-secondary:hover {
            background-color: #d1d5db;
        }

        /* Bookmarks list */
        .bookmarks-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.5rem;
        }

        .bookmark-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border-bottom: 1px solid #f3f4f6;
            cursor: pointer;
        }

        .bookmark-item:last-child {
            border-bottom: none;
        }

        .bookmark-item:hover {
            background-color: #f9fafb;
        }

        .bookmark-info {
            flex-grow: 1;
        }

        .bookmark-name {
            font-weight: 500;
            color: #1f2937;
            margin-bottom: 0.25rem;
        }

        .bookmark-position {
            font-size: 0.875rem;
            color: #6b7280;
        }

        .bookmark-actions {
            display: flex;
            gap: 0.5rem;
        }

        .bookmark-button {
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.875rem;
            border: none;
            cursor: pointer;
        }

        .bookmark-edit {
            background-color: #dbeafe;
            color: #1e40af;
        }

        .bookmark-delete {
            background-color: #fee2e2;
            color: #991b1b;
        }

        .bookmark-button:hover {
            opacity: 0.9;
        }

        .no-bookmarks {
            text-align: center;
            padding: 2rem;
            color: #6b7280;
            font-style: italic;
        }

        /* Search result highlighting */
        .search-highlight {
            background-color: rgba(255, 255, 0, 0.4);
            position: absolute;
            z-index: 100;
            pointer-events: none;
            border-radius: 2px;
        }

        .current-search-highlight {
            background-color: rgba(255, 165, 0, 0.6);
            position: absolute;
            z-index: 101;
            pointer-events: none;
            border-radius: 2px;
            border: 2px solid rgba(255, 140, 0, 0.8);
        }

        /* Enhanced search info */
        .search-info {
            font-size: 0.9rem;
            color: #6b7280;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: #f3f4f6;
            border-radius: 0.375rem;
        }
    </style>
    <!-- PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <!-- QRious QR Code generation library -->
    <script src="https://unpkg.com/qrious@4.0.2/dist/qrious.min.js"></script>
</head>
<body>

    <!-- Status Indicator -->
    <div id="status-indicator" class="hidden">
        <span id="status-text">Loading...</span>
    </div>

    <!-- Welcome Screen (shown initially) -->
    <div id="welcome-screen">
        <div class="max-w-md mx-auto text-center">
            <h1 class="text-3xl font-bold text-gray-800 mb-4">Stage Manager Control</h1>
            <p class="text-gray-600 mb-8">Welcome to PlayScroller. Use the menu in the top right to set up your script and start a session.</p>
            <div class="bg-white p-6 rounded-xl shadow-lg">
                <p class="text-gray-700 mb-4">Current User ID:</p>
                <p id="user-id-display" class="font-mono text-sm bg-gray-100 px-4 py-2 rounded mb-6">Loading...</p>
                <button id="start-with-url-btn" class="w-full py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 font-medium">
                    Start with URL from QR Code
                </button>
                <p class="text-sm text-gray-500 mt-4">Or use the menu to manually enter a PDF URL</p>
            </div>
            <div id="url-info" class="mt-4 text-sm text-gray-600 hidden">
                <p>URL Parameter detected:</p>
                <p id="detected-url" class="font-mono text-xs bg-yellow-100 p-2 rounded"></p>
            </div>
        </div>
    </div>

    <!-- Full-screen PDF Viewer -->
    <div id="pdf-container" class="hidden">
        <!-- PDF Canvases will be rendered here -->
        <p id="loading-message" class="text-center py-12 text-gray-500">Loading PDF, please wait...</p>
    </div>

    <!-- Hamburger Menu Button -->
    <button id="menu-button" class="hidden">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
    </button>

    <!-- Side Menu Panel -->
    <div id="side-menu">
        <button class="self-end p-2 bg-transparent text-gray-500 hover:text-gray-800" onclick="window.toggleMenu()">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="-round" d="M6 18L18 6M6 6l12 12" />
            </svg>
        </button>
        <ul>
            <li><button id="set-pdf-url-btn">Set PDF URL...</button></li>
            <li><button id="find-text-btn">Find...</button></li>
            <li><button id="bookmarks-btn">Bookmarks...</button></li>
            <li><button id="show-qr-btn" class="hidden">Show Actor QR Code</button></li>
            <li><button id="reset-btn">Reset Session</button></li>
        </ul>
    </div>

    <!-- Modal for PDF URL Input -->
    <div id="pdf-url-modal" class="modal hidden">
        <div class="modal-content">
            <h3 class="modal-title">Set PDF Script URL</h3>
            <p class="modal-message">Enter the public URL of your script PDF:</p>
            <input type="url" id="pdf-url-input" placeholder="e.g., https://example.com/script.pdf" class="modal-input">
            <p class="text-sm text-gray-500 mb-4">Note: The PDF must be publicly accessible with CORS headers enabled.</p>
            <div class="modal-buttons">
                <button id="pdf-url-cancel" class="modal-button modal-button-secondary">Cancel</button>
                <button id="pdf-url-ok" class="modal-button modal-button-primary">Load PDF</button>
            </div>
        </div>
    </div>

    <!-- Modal for Find Text -->
    <div id="find-modal" class="modal hidden">
        <div class="modal-content">
            <h3 class="modal-title">Find Text in PDF</h3>
            <p class="modal-message">Enter text to search for in the PDF:</p>
            <div class="search-info">
                <p><strong>Enhanced Search:</strong> Finds multi-word phrases even if split across lines.</p>
                <p>Example: Finds "to be" even if "to" ends one line and "be" starts the next.</p>
            </div>
            <input type="text" id="find-text-input" placeholder="Enter search text (multi-word phrases supported)..." class="modal-input" autofocus>
            <div id="find-results-info" class="text-sm text-gray-600 mb-4 hidden">
                Found <span id="find-results-count">0</span> matches. Use buttons below to navigate.
            </div>
            <div class="modal-buttons">
                <button id="find-prev-btn" class="modal-button modal-button-secondary hidden">Previous</button>
                <button id="find-next-btn" class="modal-button modal-button-secondary hidden">Next</button>
                <button id="find-cancel-btn" class="modal-button modal-button-secondary">Cancel</button>
                <button id="find-ok-btn" class="modal-button modal-button-primary">Find</button>
            </div>
        </div>
    </div>

    <!-- Modal for Bookmarks -->
    <div id="bookmarks-modal" class="modal hidden">
        <div class="modal-content">
            <h3 class="modal-title">Bookmarks</h3>
            <p class="modal-message">Manage your bookmarks. Click to jump to a location.</p>

            <div id="bookmarks-list" class="bookmarks-list">
                <!-- Bookmarks will be dynamically added here -->
                <div class="no-bookmarks">No bookmarks yet. Create one using the button below.</div>
            </div>

            <div class="modal-buttons">
                <button id="bookmark-add-btn" class="modal-button modal-button-primary">Add Current Position</button>
                <button id="bookmarks-close-btn" class="modal-button modal-button-secondary">Close</button>
            </div>
        </div>
    </div>

    <!-- Modal for Edit Bookmark -->
    <div id="edit-bookmark-modal" class="modal hidden">
        <div class="modal-content">
            <h3 class="modal-title">Edit Bookmark</h3>
            <p class="modal-message">Edit bookmark name (leave blank to delete):</p>
            <input type="text" id="edit-bookmark-input" placeholder="Bookmark name..." class="modal-input" autofocus>
            <div class="modal-buttons">
                <button id="edit-bookmark-cancel" class="modal-button modal-button-secondary">Cancel</button>
                <button id="edit-bookmark-save" class="modal-button modal-button-primary">Save</button>
            </div>
        </div>
    </div>

    <!-- Modal for QR Code Display - FULL SCREEN -->
    <div id="qr-modal" class="hidden">
        <button class="close-qr-btn" id="qr-modal-close">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
        </button>
        <div id="qr-modal-content">
            <h2 class="qr-title">Actor Sync QR Code</h2>
            <p class="qr-instructions">Actors should scan this QR code with their device cameras to join the session</p>
            <div id="qr-code-display">
                <!-- QR code will be rendered here -->
            </div>
            <div class="session-info">
                Session ID: <span id="session-id-display"></span>
            </div>
        </div>
    </div>

    <!-- Error Modal -->
    <div id="error-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="error-title" class="modal-title text-red-600">Error</h3>
            <p id="error-message" class="modal-message"></p>
            <div class="modal-buttons">
                <button id="error-close" class="modal-button modal-button-primary">Close</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getDatabase, ref, set, update } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // --- Global Firebase Variables ---
        const firebaseConfig = {

          apiKey: "AIzaSyBG9pzEdllxWnZu0zYQMXqEFzJWNAVv6Lw",
          authDomain: "playscroller.firebaseapp.com",
          projectId: "playscroller",
          storageBucket: "playscroller.appspot.com",
          messagingSenderId: "86147104940",
          appId: "1:86147104940:web:f1bd908e1206795f9d1f09"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);

        let rtdb, auth, userId;
        let pdfDoc = null;
        let pdfContainer;
        let currentSessionId = null;
        let currentPdfUrl = null;
        let pdfUrlFromParam = null;

        // Search functionality
        let searchResults = [];
        let currentSearchIndex = -1;
        let searchHighlights = [];

        // Bookmarks functionality
        const BOOKMARKS_COOKIE_NAME = 'playscroller_bookmarks';
        const BOOKMARKS_COOKIE_EXPIRY_DAYS = 365;
        let bookmarks = [];

        // Ensure PDF.js worker is set up
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        // --- Cookie Management Functions ---
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + encodeURIComponent(value) + expires + "; path=/; SameSite=Lax";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) {
                    return decodeURIComponent(c.substring(nameEQ.length, c.length));
                }
            }
            return null;
        }

        function deleteCookie(name) {
            setCookie(name, "", -1);
        }

        // --- Bookmarks Functions ---
        function saveBookmarksToCookie() {
            try {
                const bookmarksData = JSON.stringify(bookmarks);
                setCookie(BOOKMARKS_COOKIE_NAME, bookmarksData, BOOKMARKS_COOKIE_EXPIRY_DAYS);
                console.log('Bookmarks saved to cookie:', bookmarks);
            } catch (error) {
                console.error('Error saving bookmarks to cookie:', error);
            }
        }

        function loadBookmarksFromCookie() {
            try {
                const cookieData = getCookie(BOOKMARKS_COOKIE_NAME);
                if (cookieData) {
                    const parsedData = JSON.parse(cookieData);
                    if (Array.isArray(parsedData)) {
                        bookmarks = parsedData;
                        // Sort bookmarks by page number and percent
                        bookmarks.sort((a, b) => {
                            if (a.page === b.page) {
                                return a.percent - b.percent;
                            }
                            return a.page - b.page;
                        });
                        console.log('Bookmarks loaded from cookie:', bookmarks);
                        return true;
                    }
                }
            } catch (error) {
                console.error('Error loading bookmarks from cookie:', error);
                deleteCookie(BOOKMARKS_COOKIE_NAME);
            }
            return false;
        }

        function addBookmark(name, page, percent) {
            const bookmark = {
                id: Date.now().toString(36) + Math.random().toString(36).substring(2),
                name: name,
                page: page,
                percent: percent,
                timestamp: Date.now()
            };

            bookmarks.push(bookmark);
            // Sort bookmarks after adding
            bookmarks.sort((a, b) => {
                if (a.page === b.page) {
                    return a.percent - b.percent;
                }
                return a.page - b.page;
            });

            saveBookmarksToCookie();
            renderBookmarksList();
            return bookmark;
        }

        function updateBookmark(id, newName) {
            const index = bookmarks.findIndex(b => b.id === id);
            if (index !== -1) {
                if (newName.trim() === "") {
                    // Remove bookmark if name is blank
                    bookmarks.splice(index, 1);
                } else {
                    // Update bookmark name
                    bookmarks[index].name = newName.trim();
                }
                saveBookmarksToCookie();
                renderBookmarksList();
                return true;
            }
            return false;
        }

        function deleteBookmark(id) {
            const index = bookmarks.findIndex(b => b.id === id);
            if (index !== -1) {
                bookmarks.splice(index, 1);
                saveBookmarksToCookie();
                renderBookmarksList();
                return true;
            }
            return false;
        }

        function getCurrentPositionForBookmark() {
            const state = getCurrentScrollState();
            if (!state) return null;

            return {
                page: state.page,
                percent: state.y_percent,
                defaultName: `Page ${state.page}, ${state.y_percent.toFixed(0)}%`
            };
        }

        function jumpToBookmark(bookmark) {
            if (!pdfDoc) return;

            scrollToPosition(bookmark.page, bookmark.percent);
            closeBookmarksModal();
            updateStatus(`Jumped to: ${bookmark.name}`);
        }

        function renderBookmarksList() {
            const bookmarksList = document.getElementById('bookmarks-list');
            if (!bookmarksList) return;

            if (bookmarks.length === 0) {
                bookmarksList.innerHTML = '<div class="no-bookmarks">No bookmarks yet. Create one using the button below.</div>';
                return;
            }

            bookmarksList.innerHTML = '';

            bookmarks.forEach(bookmark => {
                const bookmarkItem = document.createElement('div');
                bookmarkItem.className = 'bookmark-item';
                bookmarkItem.dataset.id = bookmark.id;

                bookmarkItem.innerHTML = `
                    <div class="bookmark-info">
                        <div class="bookmark-name">${bookmark.name}</div>
                        <div class="bookmark-position">Page ${bookmark.page}, ${bookmark.percent.toFixed(0)}%</div>
                    </div>
                    <div class="bookmark-actions">
                        <button class="bookmark-button bookmark-edit" onclick="event.stopPropagation(); editBookmark('${bookmark.id}')">Edit</button>
                        <button class="bookmark-button bookmark-delete" onclick="event.stopPropagation(); deleteBookmark('${bookmark.id}')">Delete</button>
                    </div>
                `;

                bookmarkItem.addEventListener('click', () => jumpToBookmark(bookmark));
                bookmarksList.appendChild(bookmarkItem);
            });
        }

        // --- ENHANCED Search Functions for Multi-Word Phrases ---
        async function searchTextInPDF(searchText) {
            if (!pdfDoc) {
                showError('No PDF Loaded', 'Please load a PDF first.');
                return [];
            }

            searchResults = [];
            clearSearchHighlights();

            const searchTextLower = searchText.toLowerCase();
            const searchWords = searchTextLower.split(/\s+/).filter(word => word.length > 0);

            // If it's a single word, use simpler search
            if (searchWords.length === 1) {
                return await searchSingleWord(searchTextLower);
            }

            // For multi-word phrases, use advanced search
            return await searchMultiWordPhrase(searchTextLower, searchWords);
        }

        async function searchSingleWord(word) {
            const results = [];

            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                try {
                    const page = await pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();

                    const canvas = document.getElementById(`pdf-page-${pageNum}`);
                    if (!canvas) continue;

                    const viewport = page.getViewport({ scale: 1 });
                    const scale = canvas.width / viewport.width;

                    const textItems = textContent.items;
                    for (let i = 0; i < textItems.length; i++) {
                        const textItem = textItems[i];
                        const text = textItem.str;
                        const textLower = text.toLowerCase();

                        let searchIndex = 0;
                        while ((searchIndex = textLower.indexOf(word, searchIndex)) !== -1) {
                            const result = createSearchResult(textItem, searchIndex, word.length, scale, viewport, pageNum, text);
                            if (result) {
                                results.push(result);
                            }
                            searchIndex += word.length;
                        }
                    }
                } catch (error) {
                    console.error(`Error searching page ${pageNum}:`, error);
                }
            }

            return results;
        }

        async function searchMultiWordPhrase(searchPhrase, searchWords) {
            const results = [];

            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                try {
                    const page = await pdfDoc.getPage(pageNum);
                    const textContent = await page.getTextContent();

                    const canvas = document.getElementById(`pdf-page-${pageNum}`);
                    if (!canvas) continue;

                    const viewport = page.getViewport({ scale: 1 });
                    const scale = canvas.width / viewport.width;

                    const textItems = textContent.items;

                    // Strategy 1: Try exact phrase match (with spaces between items)
                    const exactResults = await searchExactPhrase(textItems, searchPhrase, scale, viewport, pageNum);
                    results.push(...exactResults);

                    // Strategy 2: Try phrase without spaces (for line breaks)
                    if (exactResults.length === 0) {
                        const noSpaceResults = await searchPhraseWithoutSpaces(textItems, searchWords, scale, viewport, pageNum);
                        results.push(...noSpaceResults);
                    }

                    // Strategy 3: Try fuzzy matching across text items
                    if (results.length === 0 && searchWords.length > 1) {
                        const fuzzyResults = await searchFuzzyPhrase(textItems, searchWords, scale, viewport, pageNum);
                        results.push(...fuzzyResults);
                    }

                } catch (error) {
                    console.error(`Error searching page ${pageNum}:`, error);
                }
            }

            return results;
        }

        async function searchExactPhrase(textItems, searchPhrase, scale, viewport, pageNum) {
            const results = [];

            // Build concatenated text from all text items WITH estimated spaces
            let pageTextWithSpaces = '';
            let pageTextWithoutSpaces = '';
            const textPositions = [];

            for (let i = 0; i < textItems.length; i++) {
                const textItem = textItems[i];
                const text = textItem.str;

                // Add to pageTextWithoutSpaces
                pageTextWithoutSpaces += text;

                // For pageTextWithSpaces, estimate if there should be a space
                if (i > 0) {
                    const prevItem = textItems[i - 1];
                    const prevX = prevItem.transform[4];
                    const prevWidth = prevItem.width;
                    const currentX = textItem.transform[4];
                    const charWidth = prevWidth / Math.max(1, prevItem.str.length);

                    // If the distance suggests a gap, add a space
                    if (currentX - (prevX + prevWidth) > charWidth * 0.5) {
                        pageTextWithSpaces += ' ';
                    }
                }

                pageTextWithSpaces += text;

                // Store position information
                textPositions.push({
                    text: text,
                    transform: textItem.transform,
                    width: textItem.width,
                    height: textItem.height || 15,
                    startIndexWithSpaces: pageTextWithSpaces.length - text.length,
                    endIndexWithSpaces: pageTextWithSpaces.length,
                    startIndexWithoutSpaces: pageTextWithoutSpaces.length - text.length,
                    endIndexWithoutSpaces: pageTextWithoutSpaces.length
                });
            }

            // Try matching with spaces first
            const pageTextWithSpacesLower = pageTextWithSpaces.toLowerCase();
            let searchIndex = 0;

            while ((searchIndex = pageTextWithSpacesLower.indexOf(searchPhrase, searchIndex)) !== -1) {
                const matchStart = searchIndex;
                const matchEnd = searchIndex + searchPhrase.length;

                // Find which text items contain this match
                const matchingItems = findMatchingItems(matchStart, matchEnd, textPositions, true);

                if (matchingItems.length > 0) {
                    for (const match of matchingItems) {
                        const result = createSearchResultFromMatch(match, scale, viewport, pageNum, searchPhrase);
                        if (result) {
                            results.push(result);
                        }
                    }
                }

                searchIndex = matchEnd;
            }

            return results;
        }

        async function searchPhraseWithoutSpaces(textItems, searchWords, scale, viewport, pageNum) {
            const results = [];

            // Build text without any spaces
            let concatenatedText = '';
            const textPositions = [];

            for (let i = 0; i < textItems.length; i++) {
                const textItem = textItems[i];
                const text = textItem.str;

                const startIndex = concatenatedText.length;
                concatenatedText += text;
                const endIndex = concatenatedText.length;

                textPositions.push({
                    text: text,
                    transform: textItem.transform,
                    width: textItem.width,
                    height: textItem.height || 15,
                    startIndex: startIndex,
                    endIndex: endIndex,
                    itemIndex: i
                });
            }

            // Remove spaces from search phrase for matching
            const searchPhraseNoSpaces = searchWords.join('');
            const concatenatedTextLower = concatenatedText.toLowerCase();
            let searchIndex = 0;

            while ((searchIndex = concatenatedTextLower.indexOf(searchPhraseNoSpaces, searchIndex)) !== -1) {
                const matchStart = searchIndex;
                const matchEnd = searchIndex + searchPhraseNoSpaces.length;

                // Find which text items contain this match
                const matchingItems = findMatchingItemsSimple(matchStart, matchEnd, textPositions);

                if (matchingItems.length > 0) {
                    // Create a combined result for the entire phrase
                    const result = createCombinedResult(matchingItems, scale, viewport, pageNum, searchWords.join(' '));
                    if (result) {
                        results.push(result);
                    }
                }

                searchIndex = matchEnd;
            }

            return results;
        }

        async function searchFuzzyPhrase(textItems, searchWords, scale, viewport, pageNum) {
            const results = [];

            // For each position where first word appears
            for (let i = 0; i < textItems.length - searchWords.length + 1; i++) {
                let matchesAllWords = true;
                const matchedItems = [];

                // Check if subsequent text items contain the search words
                for (let j = 0; j < searchWords.length; j++) {
                    const textItem = textItems[i + j];
                    const text = textItem.str.toLowerCase();

                    if (text.includes(searchWords[j])) {
                        // Find position of the word within this text item
                        const wordIndex = text.indexOf(searchWords[j]);
                        matchedItems.push({
                            item: textItem,
                            wordIndex: wordIndex,
                            wordLength: searchWords[j].length,
                            word: searchWords[j]
                        });
                    } else {
                        matchesAllWords = false;
                        break;
                    }
                }

                if (matchesAllWords && matchedItems.length === searchWords.length) {
                    // Check if these items are reasonably close (not too far apart)
                    if (areItemsCloseTogether(matchedItems)) {
                        const result = createCombinedResultFromItems(matchedItems, scale, viewport, pageNum, searchWords.join(' '));
                        if (result) {
                            results.push(result);
                        }
                    }
                }
            }

            return results;
        }

        function findMatchingItems(matchStart, matchEnd, textPositions, useWithSpaces) {
            const matchingItems = [];
            let currentPos = matchStart;

            while (currentPos < matchEnd) {
                const itemIndex = textPositions.findIndex(item => {
                    const startIndex = useWithSpaces ? item.startIndexWithSpaces : item.startIndexWithoutSpaces;
                    const endIndex = useWithSpaces ? item.endIndexWithSpaces : item.endIndexWithoutSpaces;
                    return currentPos >= startIndex && currentPos < endIndex;
                });

                if (itemIndex === -1) break;

                const item = textPositions[itemIndex];
                const startIndex = useWithSpaces ? item.startIndexWithSpaces : item.endIndexWithoutSpaces;

                matchingItems.push({
                    item: item,
                    itemIndex: itemIndex,
                    matchStartInItem: Math.max(0, matchStart - startIndex),
                    matchEndInItem: Math.min(item.text.length, matchEnd - startIndex)
                });

                currentPos = useWithSpaces ? item.endIndexWithSpaces : item.endIndexWithoutSpaces;
            }

            return matchingItems;
        }

        function findMatchingItemsSimple(matchStart, matchEnd, textPositions) {
            const matchingItems = [];
            let currentPos = matchStart;

            while (currentPos < matchEnd) {
                const itemIndex = textPositions.findIndex(item => {
                    return currentPos >= item.startIndex && currentPos < item.endIndex;
                });

                if (itemIndex === -1) break;

                const item = textPositions[itemIndex];

                matchingItems.push({
                    item: item,
                    itemIndex: itemIndex,
                    matchStartInItem: Math.max(0, matchStart - item.startIndex),
                    matchEndInItem: Math.min(item.text.length, matchEnd - item.startIndex)
                });

                currentPos = item.endIndex;
            }

            return matchingItems;
        }

        function areItemsCloseTogether(matchedItems) {
            if (matchedItems.length <= 1) return true;

            for (let i = 1; i < matchedItems.length; i++) {
                const prevItem = matchedItems[i - 1].item;
                const currentItem = matchedItems[i].item;

                // Check vertical position (should be similar for same line)
                const prevY = prevItem.transform[5];
                const currentY = currentItem.transform[5];
                const yDiff = Math.abs(prevY - currentY);

                // If items are more than 20 units apart vertically, they're probably on different lines
                if (yDiff > 20) {
                    return false;
                }
            }

            return true;
        }

        function createSearchResult(textItem, startIndex, length, scale, viewport, pageNum, originalText) {
            const totalWidth = textItem.width * scale;
            const charWidth = totalWidth / Math.max(1, textItem.str.length);
            const matchedWidth = length * charWidth;

            const baseX = textItem.transform[4] * scale;
            const offsetX = startIndex * charWidth;
            const x = baseX + offsetX;

            const textHeight = (textItem.height || 15) * scale;
            const y = (viewport.height - textItem.transform[5]) * scale - textHeight;

            return {
                page: pageNum,
                x: x,
                y: y,
                width: matchedWidth,
                height: textHeight,
                text: originalText.substring(startIndex, startIndex + length)
            };
        }

        function createSearchResultFromMatch(match, scale, viewport, pageNum, searchText) {
            const item = match.item;
            const matchStartInItem = match.matchStartInItem;
            const matchEndInItem = match.matchEndInItem;

            const totalWidth = item.width * scale;
            const charWidth = totalWidth / Math.max(1, item.text.length);
            const matchedWidth = (matchEndInItem - matchStartInItem) * charWidth;

            const baseX = item.transform[4] * scale;
            const offsetX = matchStartInItem * charWidth;
            const x = baseX + offsetX;

            const textHeight = (item.height || 15) * scale;
            const y = (viewport.height - item.transform[5]) * scale - textHeight;

            return {
                page: pageNum,
                x: x,
                y: y,
                width: matchedWidth,
                height: textHeight,
                text: item.text.substring(matchStartInItem, matchEndInItem)
            };
        }

        function createCombinedResult(matchingItems, scale, viewport, pageNum, searchText) {
            if (matchingItems.length === 0) return null;

            // For combined results, create a result for the first matching item
            const firstMatch = matchingItems[0];
            const item = firstMatch.item;

            const totalWidth = item.width * scale;
            const charWidth = totalWidth / Math.max(1, item.text.length);
            const matchedWidth = (firstMatch.matchEndInItem - firstMatch.matchStartInItem) * charWidth;

            const baseX = item.transform[4] * scale;
            const offsetX = firstMatch.matchStartInItem * charWidth;
            const x = baseX + offsetX;

            const textHeight = (item.height || 15) * scale;
            const y = (viewport.height - item.transform[5]) * scale - textHeight;

            return {
                page: pageNum,
                x: x,
                y: y,
                width: matchedWidth,
                height: textHeight,
                text: searchText,
                isCombined: true,
                matchingItems: matchingItems
            };
        }

        function createCombinedResultFromItems(matchedItems, scale, viewport, pageNum, searchText) {
            if (matchedItems.length === 0) return null;

            // Use the first item for positioning
            const firstItem = matchedItems[0];
            const item = firstItem.item;

            const totalWidth = item.width * scale;
            const charWidth = totalWidth / Math.max(1, item.text.length);
            const matchedWidth = firstItem.wordLength * charWidth;

            const baseX = item.transform[4] * scale;
            const offsetX = firstItem.wordIndex * charWidth;
            const x = baseX + offsetX;

            const textHeight = (item.height || 15) * scale;
            const y = (viewport.height - item.transform[5]) * scale - textHeight;

            return {
                page: pageNum,
                x: x,
                y: y,
                width: matchedWidth,
                height: textHeight,
                text: searchText,
                isCombined: true,
                matchedItems: matchedItems
            };
        }

        function clearSearchHighlights() {
            searchHighlights.forEach(highlight => {
                if (highlight.parentNode) {
                    highlight.parentNode.removeChild(highlight);
                }
            });
            searchHighlights = [];
        }

        function showSearchResults() {
            clearSearchHighlights();

            if (searchResults.length === 0) {
                document.getElementById('find-results-info').classList.add('hidden');
                document.getElementById('find-prev-btn').classList.add('hidden');
                document.getElementById('find-next-btn').classList.add('hidden');
                return;
            }

            // Update results info
            const resultsInfo = document.getElementById('find-results-info');
            const resultsCount = document.getElementById('find-results-count');
            resultsCount.textContent = searchResults.length;
            resultsInfo.classList.remove('hidden');

            // Show navigation buttons
            document.getElementById('find-prev-btn').classList.remove('hidden');
            document.getElementById('find-next-btn').classList.remove('hidden');

            // Create highlights for all results
            searchResults.forEach((result, index) => {
                const canvas = document.getElementById(`pdf-page-${result.page}`);
                if (!canvas) return;

                const highlight = document.createElement('div');
                highlight.className = 'search-highlight';
                highlight.style.left = `${result.x - 2}px`;
                highlight.style.top = `${result.y}px`;
                highlight.style.width = `${result.width + 4}px`;
                highlight.style.height = `${result.height + 3}px`;
                highlight.style.position = 'absolute';
                highlight.dataset.index = index;

                // Find the canvas container
                const canvasParent = canvas.parentNode;
                if (canvasParent) {
                    canvasParent.appendChild(highlight);
                    searchHighlights.push(highlight);
                }
            });

            // Highlight current result
            if (currentSearchIndex >= 0 && currentSearchIndex < searchResults.length) {
                const currentResult = searchResults[currentSearchIndex];
                const canvas = document.getElementById(`pdf-page-${currentResult.page}`);
                if (canvas) {
                    const currentHighlight = document.createElement('div');
                    currentHighlight.className = 'current-search-highlight';
                    currentHighlight.style.left = `${currentResult.x - 4}px`;
                    currentHighlight.style.top = `${currentResult.y - 2}px`;
                    currentHighlight.style.width = `${currentResult.width + 8}px`;
                    currentHighlight.style.height = `${result.height + 7}px`;
                    currentHighlight.style.position = 'absolute';

                    const canvasParent = canvas.parentNode;
                    if (canvasParent) {
                        canvasParent.appendChild(currentHighlight);
                        searchHighlights.push(currentHighlight);
                    }

                    // Scroll to the current result
                    scrollToSearchResult(currentResult);
                }
            }
        }

        function scrollToSearchResult(result) {
            if (!pdfContainer || !result) return;

            const canvas = document.getElementById(`pdf-page-${result.page}`);
            if (!canvas) return;

            // Calculate scroll position to center the result
            const canvasTop = canvas.offsetTop;
            const targetScrollY = canvasTop + result.y - (pdfContainer.clientHeight / 2) + (result.height / 2);

            pdfContainer.scrollTo({
                top: targetScrollY,
                behavior: 'smooth'
            });

            updateStatus(`Found "${result.text}" (${currentSearchIndex + 1}/${searchResults.length})`);
        }

        function goToNextSearchResult() {
            if (searchResults.length === 0) return;

            currentSearchIndex = (currentSearchIndex + 1) % searchResults.length;
            showSearchResults();
        }

        function goToPrevSearchResult() {
            if (searchResults.length === 0) return;

            currentSearchIndex = (currentSearchIndex - 1 + searchResults.length) % searchResults.length;
            showSearchResults();
        }

        // --- Utility Functions ---
        function scrollToPosition(page, percent) {
            if (!pdfDoc || !pdfContainer) return;

            const canvas = document.getElementById(`pdf-page-${page}`);
            if (!canvas) return;

            const canvasTop = canvas.offsetTop;
            const canvasHeight = canvas.offsetHeight;
            const targetScrollY = canvasTop + (canvasHeight * (percent / 100));

            pdfContainer.scrollTo({
                top: targetScrollY,
                behavior: 'smooth'
            });
        }

        // Debug logging (to console only)
        function logDebug(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] ${message}`);
        }

        // Update status indicator
        function updateStatus(message, isError = false) {
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');

            statusText.textContent = message;
            statusIndicator.classList.remove('hidden');

            if (isError) {
                statusIndicator.style.backgroundColor = 'rgba(220, 38, 38, 0.8)'; // red
            } else {
                statusIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            }
        }

        // Function to get actor app URL from current SM app URL
        function getActorAppUrl() {
            const currentUrl = window.location.href;
            // Replace "sm-app.html" with "actor-app.html" in the current URL
            const actorAppUrl = currentUrl.replace(/sm-app\.html.*$/, 'actor-app.html');
            return actorAppUrl;
        }

        // Generate a session ID
        function generateSessionId() {
            return 'SESS-' + Date.now().toString(36) + Math.random().toString(36).substring(2, 6).toUpperCase();
        }

        // Convert Google Drive view link to direct download link
        function convertGoogleDriveLink(url) {
            if (!url) return url;

            logDebug(`Converting Google Drive link: ${url}`);

            // Pattern for Google Drive view links
            const viewPattern = /drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/;
            const match = url.match(viewPattern);

            if (match) {
                const fileId = match[1];
                const directUrl = `https://drive.google.com/uc?export=download&id=${fileId}`;
                logDebug(`Converted to direct download: ${directUrl}`);
                return directUrl;
            }

            // If it's already a direct link or not Google Drive, return as-is
            return url;
        }

        // Show/hide menu
        window.toggleMenu = () => {
            const sideMenu = document.getElementById('side-menu');
            sideMenu.classList.toggle('open');
        };

        // --- Modal Functions ---
        function showPdfUrlModal() {
            document.getElementById('pdf-url-modal').classList.remove('hidden');
            document.getElementById('pdf-url-input').focus();
        }

        function closePdfUrlModal() {
            document.getElementById('pdf-url-modal').classList.add('hidden');
            document.getElementById('pdf-url-input').value = '';
        }

        function showFindModal() {
            document.getElementById('find-modal').classList.remove('hidden');
            document.getElementById('find-text-input').focus();
            document.getElementById('find-text-input').value = '';

            // Reset search state
            searchResults = [];
            currentSearchIndex = -1;
            clearSearchHighlights();

            document.getElementById('find-results-info').classList.add('hidden');
            document.getElementById('find-prev-btn').classList.add('hidden');
            document.getElementById('find-next-btn').classList.add('hidden');
        }

        function closeFindModal() {
            document.getElementById('find-modal').classList.add('hidden');
            clearSearchHighlights();
        }

        function showBookmarksModal() {
            document.getElementById('bookmarks-modal').classList.remove('hidden');
            renderBookmarksList();
        }

        function closeBookmarksModal() {
            document.getElementById('bookmarks-modal').classList.add('hidden');
        }

        function showEditBookmarkModal(bookmarkId, currentName) {
            document.getElementById('edit-bookmark-modal').classList.remove('hidden');
            document.getElementById('edit-bookmark-input').value = currentName || '';
            document.getElementById('edit-bookmark-input').focus();
            document.getElementById('edit-bookmark-input').dataset.bookmarkId = bookmarkId;
        }

        function closeEditBookmarkModal() {
            document.getElementById('edit-bookmark-modal').classList.add('hidden');
            document.getElementById('edit-bookmark-input').value = '';
            document.getElementById('edit-bookmark-input').dataset.bookmarkId = '';
        }

        // Global functions for event handlers
        window.editBookmark = function(bookmarkId) {
            const bookmark = bookmarks.find(b => b.id === bookmarkId);
            if (bookmark) {
                showEditBookmarkModal(bookmarkId, bookmark.name);
            }
        };

        window.deleteBookmark = function(bookmarkId) {
            if (confirm('Are you sure you want to delete this bookmark?')) {
                deleteBookmark(bookmarkId);
            }
        };

        function showQrModal() {
            if (!currentSessionId || !currentPdfUrl) {
                showError('No Active Session', 'Please load a PDF first to start a session.');
                return;
            }

            const actorAppUrl = getActorAppUrl();
            const actorSyncUrl = `${actorAppUrl}?session_id=${currentSessionId}&pdf_url=${encodeURIComponent(currentPdfUrl)}`;

            logDebug(`QR Code URL: ${actorSyncUrl}`);

            // Update session ID display
            document.getElementById('session-id-display').textContent = currentSessionId;

            // Generate QR code - make it as large as possible
            const qrDisplay = document.getElementById('qr-code-display');
            qrDisplay.innerHTML = '';

            // Create container for QR code
            const qrContainer = document.createElement('div');
            qrContainer.style.width = '100%';
            qrContainer.style.height = '100%';
            qrContainer.style.display = 'flex';
            qrContainer.style.justifyContent = 'center';
            qrContainer.style.alignItems = 'center';

            const qrCanvas = document.createElement('canvas');
            qrContainer.appendChild(qrCanvas);
            qrDisplay.appendChild(qrContainer);

            // Calculate optimal size based on screen dimensions
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const qrSize = Math.min(screenWidth, screenHeight) * 0.8;

            new QRious({
                element: qrCanvas,
                value: actorSyncUrl,
                size: qrSize,
                background: '#ffffff',
                foreground: '#000000', // Black for maximum contrast
                level: 'H' // Highest error correction
            });

            document.getElementById('qr-modal').classList.remove('hidden');

            // Hide menu button when QR code is shown
            document.getElementById('menu-button').classList.add('hidden');
            document.getElementById('status-indicator').classList.add('hidden');
        }

        function closeQrModal() {
            document.getElementById('qr-modal').classList.add('hidden');

            // Show menu button again
            document.getElementById('menu-button').classList.remove('hidden');
            document.getElementById('status-indicator').classList.remove('hidden');
        }

        function showError(title, message) {
            logDebug(`Error: ${title} - ${message}`);
            updateStatus(`Error: ${title}`, true);
            document.getElementById('error-title').textContent = title;
            document.getElementById('error-message').textContent = message;
            document.getElementById('error-modal').classList.remove('hidden');
        }

        function closeErrorModal() {
            document.getElementById('error-modal').classList.add('hidden');
        }

        // Extract URL parameters
        function extractUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const pdfUrl = urlParams.get('pdfurl') || urlParams.get('pdf_url');

            if (pdfUrl) {
                // Decode the URL (it might be encoded)
                const decodedUrl = decodeURIComponent(pdfUrl);
                pdfUrlFromParam = decodedUrl;

                // Show the detected URL on welcome screen
                document.getElementById('url-info').classList.remove('hidden');
                document.getElementById('detected-url').textContent = decodedUrl;

                // Pre-fill the modal input
                document.getElementById('pdf-url-input').value = decodedUrl;

                logDebug(`Extracted PDF URL from parameters: ${decodedUrl}`);
            }

            return pdfUrlFromParam;
        }

        // --- Core App Initialization ---
        async function initializeFirebase() {
            try {
                logDebug('Initializing Firebase...');

                if (!firebaseConfig.apiKey || Object.keys(firebaseConfig).length === 0) {
                    showError('Configuration Error', 'Firebase API Key is missing or Firebase configuration is empty.');
                    return;
                }

                rtdb = getDatabase(app);
                auth = getAuth(app);

                // Authenticate user
                logDebug('Authenticating user...');
                updateStatus('Authenticating...');
                await signInAnonymously(auth);
                userId = auth.currentUser?.uid || crypto.randomUUID();
                document.getElementById('user-id-display').textContent = userId;
                logDebug(`User ID: ${userId}`);

                // Show menu button
                document.getElementById('menu-button').classList.remove('hidden');

                // Load bookmarks from cookie
                loadBookmarksFromCookie();

                // Extract URL parameters
                extractUrlParameters();

                if (pdfUrlFromParam) {
                    // Auto-start with URL from QR code
                    logDebug(`Auto-starting with PDF URL: ${pdfUrlFromParam}`);
                    updateStatus(`Loading PDF from URL...`);
                    document.getElementById('welcome-screen').classList.add('hidden');
                    await startSession(pdfUrlFromParam);
                } else {
                    logDebug('No PDF URL parameter found, showing welcome screen');
                    updateStatus('Ready - No PDF loaded');
                }

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                showError('Initialization Failed', `Could not initialize Firebase: ${error.message}`);
            }
        }

        // --- PDF Rendering Functions ---
        async function renderPage(pageNumber, pdfPage) {
            const viewport = pdfPage.getViewport({ scale: 1.5 });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            canvas.id = `pdf-page-${pageNumber}`;
            canvas.setAttribute('data-page', pageNumber);

            await pdfPage.render({ canvasContext: context, viewport: viewport }).promise;
            pdfContainer.appendChild(canvas);
        }

        async function loadAndRenderPDF(pdfUrl) {
            logDebug(`Loading PDF from: ${pdfUrl}`);
            updateStatus(`Loading PDF...`);

            // Show PDF container immediately with loading message
            document.getElementById('pdf-container').classList.remove('hidden');
            document.getElementById('pdf-container').innerHTML = '<p id="loading-message" class="text-center py-12 text-gray-500">Loading PDF, please wait...</p>';

            try {
                // Convert Google Drive link if needed
                const finalPdfUrl = convertGoogleDriveLink(pdfUrl);
                logDebug(`Final PDF URL: ${finalPdfUrl}`);

                const pdf = await pdfjsLib.getDocument({
                    url: finalPdfUrl,
                    withCredentials: false
                }).promise;

                pdfDoc = pdf;
                pdfContainer.innerHTML = ''; // Clear loading message

                // Render all pages
                updateStatus(`Rendering ${pdf.numPages} pages...`);
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    await renderPage(i, page);
                }

                logDebug(`Successfully loaded PDF with ${pdf.numPages} pages`);
                updateStatus(`Loaded ${pdf.numPages} pages - Session: ${currentSessionId}`);

                // Initial broadcast after loading
                broadcastScrollState();

            } catch (error) {
                console.error("PDF Loading Error:", error);
                logDebug(`PDF Loading Error: ${error.message}`);
                let errorMsg = `Could not load PDF from URL. ${error.message}`;

                // Provide more helpful error messages
                if (error.message.includes('CORS')) {
                    errorMsg += '\n\nCORS Error: The PDF server needs to allow cross-origin requests.';
                } else if (error.message.includes('404') || error.message.includes('Not Found')) {
                    errorMsg += '\n\nFile not found. Check the URL.';
                } else if (error.message.includes('Invalid PDF')) {
                    errorMsg += '\n\nThis might not be a valid PDF file.';
                }

                showError('PDF Loading Error', errorMsg);
                pdfContainer.innerHTML = '<p id="loading-message" class="text-center py-12 text-gray-500">PDF loading failed.</p>';
                pdfDoc = null;
                // Reset session
                currentSessionId = null;
                currentPdfUrl = null;
                document.getElementById('show-qr-btn').classList.add('hidden');
            }
        }

        // Start a new session
        async function startSession(pdfUrl) {
            if (!rtdb || !userId) {
                showError('System Error', 'Firebase Realtime Database not initialized or User not authenticated.');
                return;
            }

            currentPdfUrl = pdfUrl;
            currentSessionId = generateSessionId();

            logDebug(`Starting session: ${currentSessionId} with PDF: ${pdfUrl}`);
            updateStatus(`Starting session ${currentSessionId}...`);

            // Create session metadata in Realtime Database
            const metadataRef = ref(rtdb, `sessions/${currentSessionId}/metadata`);
            const sessionMetadata = {
                sm_id: userId,
                pdf_url: pdfUrl,
                timestamp: Date.now(),
                status: 'active'
            };

            // Initialize view state in Realtime Database
            const viewStateRef = ref(rtdb, `sessions/${currentSessionId}/viewState`);
            const initialViewState = {
                page: 1,
                y_percent: 0,
                timestamp: Date.now()
            };

            try {
                await set(metadataRef, sessionMetadata);
                await set(viewStateRef, initialViewState);

                logDebug(`Session created in Firebase: ${currentSessionId}`);
                updateStatus(`Session ${currentSessionId} created, loading PDF...`);

                // Load and render PDF
                await loadAndRenderPDF(pdfUrl);

                // Update UI
                document.getElementById('pdf-container').classList.remove('hidden');
                document.getElementById('show-qr-btn').classList.remove('hidden');

                // Hide welcome screen if still showing
                document.getElementById('welcome-screen').classList.add('hidden');

                logDebug(`Session started successfully: ${currentSessionId}`);
                updateStatus(`Session ${currentSessionId} active - ${pdfDoc ? pdfDoc.numPages : 0} pages`);

            } catch (error) {
                console.error("Session start failed:", error);
                logDebug(`Session start failed: ${error.message}`);
                showError('Session Failed', `Could not start session or write to Realtime Database. Error: ${error.message}`);
                currentSessionId = null;
                currentPdfUrl = null;
                document.getElementById('show-qr-btn').classList.add('hidden');
            }
        }

        // Reset session
        function resetSession() {
            logDebug('Resetting session');
            updateStatus('Resetting session...');
            currentSessionId = null;
            currentPdfUrl = null;
            pdfDoc = null;

            // Clear PDF container
            if (pdfContainer) {
                pdfContainer.innerHTML = '<p id="loading-message" class="text-center py-12 text-gray-500">No PDF loaded.</p>';
                pdfContainer.classList.add('hidden');
            }

            // Hide QR button
            document.getElementById('show-qr-btn').classList.add('hidden');

            // Show welcome screen
            document.getElementById('welcome-screen').classList.remove('hidden');
            document.getElementById('status-indicator').classList.add('hidden');

            window.toggleMenu(); // Close menu

            updateStatus('Ready - Session reset');
            setTimeout(() => {
                document.getElementById('status-indicator').classList.add('hidden');
            }, 2000);
        }

        // Throttle utility function
        const throttle = (func, limit) => {
            let inThrottle;
            return function() {
                const args = arguments;
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }

        // --- Core Scroll Logic ---
        function getCurrentScrollState() {
            const container = pdfContainer;
            const scrollY = container.scrollTop;
            const containerHeight = container.clientHeight;
            let currentCanvas = null;

            // Find the visible canvas page
            const canvases = container.querySelectorAll('canvas');
            for (const canvas of canvases) {
                const canvasTop = canvas.offsetTop;
                const canvasBottom = canvas.offsetTop + canvas.offsetHeight;

                if (scrollY >= canvasTop && scrollY < canvasBottom) {
                    currentCanvas = canvas;
                    break;
                }
            }

            if (!currentCanvas) {
                if (canvases.length > 0 && scrollY < canvases[0].offsetTop + canvases[0].offsetHeight) {
                    currentCanvas = canvases[0];
                } else if (canvases.length > 0) {
                    currentCanvas = canvases[canvases.length - 1];
                } else {
                    return null;
                }
            }

            const pageNumber = parseInt(currentCanvas.getAttribute('data-page'), 10);
            const pageHeight = currentCanvas.offsetHeight;
            const pageTop = currentCanvas.offsetTop;
            const scrollInPage = scrollY - pageTop;

            let yPercent = Math.min(100, Math.max(0, (scrollInPage / pageHeight) * 100));

            // Handle edge cases
            if (scrollY + containerHeight >= container.scrollHeight - 5) {
                yPercent = 100;
            }

            if (scrollInPage <= 10) {
                yPercent = 0;
            }

            return { page: pageNumber, y_percent: parseFloat(yPercent.toFixed(2)) };
        }

        const broadcastScrollState = throttle(async () => {
            if (!currentSessionId || !rtdb || !pdfDoc) return;

            const state = getCurrentScrollState();
            if (!state) return;

            const viewStateRef = ref(rtdb, `sessions/${currentSessionId}/viewState`);

            try {
                await update(viewStateRef, {
                    page: state.page,
                    y_percent: state.y_percent,
                    timestamp: Date.now()
                });

                logDebug(`Broadcasting: Page ${state.page} @ ${state.y_percent.toFixed(0)}%`);
                updateStatus(`Page ${state.page} @ ${state.y_percent.toFixed(0)}%`);

            } catch (e) {
                console.error("Broadcast failed:", e);
                logDebug(`Broadcast failed: ${e.message}`);
            }

        }, 150); // Throttle to 150ms

        // Event handler for scrolling
        window.handleScroll = () => {
            if (pdfDoc && currentSessionId) {
                broadcastScrollState();
            }
        };

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            pdfContainer = document.getElementById('pdf-container');

            // Fix for "Set PDF URL..." button not working
            // Add click handler directly to the button
            document.getElementById('set-pdf-url-btn').onclick = function() {
                window.toggleMenu();
                showPdfUrlModal();
            };

            document.getElementById('find-text-btn').onclick = function() {
                window.toggleMenu();
                showFindModal();
            };

            document.getElementById('bookmarks-btn').onclick = function() {
                window.toggleMenu();
                showBookmarksModal();
            };

            initializeFirebase();

            // Set up event listeners
            document.getElementById('menu-button').addEventListener('click', window.toggleMenu);

            // Menu button clicks (using onclick instead of addEventListener for reliability)
            document.getElementById('show-qr-btn').onclick = function() {
                window.toggleMenu();
                showQrModal();
            };

            document.getElementById('reset-btn').onclick = function() {
                resetSession();
            };

            // PDF URL modal buttons
            document.getElementById('pdf-url-ok').onclick = async function() {
                const pdfUrl = document.getElementById('pdf-url-input').value.trim();
                if (!pdfUrl) {
                    showError('Input Required', 'Please enter a PDF URL.');
                    return;
                }

                closePdfUrlModal();
                await startSession(pdfUrl);
            };

            document.getElementById('pdf-url-cancel').onclick = closePdfUrlModal;

            // Find modal buttons
            document.getElementById('find-ok-btn').onclick = async function() {
                const searchText = document.getElementById('find-text-input').value.trim();
                if (!searchText) {
                    showError('Input Required', 'Please enter text to search for.');
                    return;
                }

                logDebug(`Searching for: "${searchText}"`);
                updateStatus(`Searching for "${searchText}"...`);

                searchResults = await searchTextInPDF(searchText);
                currentSearchIndex = searchResults.length > 0 ? 0 : -1;

                showSearchResults();

                if (searchResults.length === 0) {
                    updateStatus(`No matches found for "${searchText}"`);
                } else {
                    updateStatus(`Found ${searchResults.length} matches for "${searchText}"`);
                }
            };

            document.getElementById('find-cancel-btn').onclick = closeFindModal;
            document.getElementById('find-prev-btn').onclick = goToPrevSearchResult;
            document.getElementById('find-next-btn').onclick = goToNextSearchResult;

            // Allow Enter key in Find input
            document.getElementById('find-text-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('find-ok-btn').click();
                }
            });

            // Bookmarks modal buttons
            document.getElementById('bookmark-add-btn').onclick = function() {
                const position = getCurrentPositionForBookmark();
                if (!position) {
                    showError('Cannot Bookmark', 'Unable to get current position.');
                    return;
                }

                const bookmark = addBookmark(position.defaultName, position.page, position.percent);
                updateStatus(`Bookmark added: ${bookmark.name}`);
            };

            document.getElementById('bookmarks-close-btn').onclick = closeBookmarksModal;

            // Edit bookmark modal buttons
            document.getElementById('edit-bookmark-save').onclick = function() {
                const bookmarkId = document.getElementById('edit-bookmark-input').dataset.bookmarkId;
                const newName = document.getElementById('edit-bookmark-input').value;

                if (updateBookmark(bookmarkId, newName)) {
                    closeEditBookmarkModal();
                    updateStatus('Bookmark updated');
                }
            };

            document.getElementById('edit-bookmark-cancel').onclick = closeEditBookmarkModal;

            // Allow Enter key in Edit bookmark input
            document.getElementById('edit-bookmark-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('edit-bookmark-save').click();
                }
            });

            // QR modal close button
            document.getElementById('qr-modal-close').onclick = closeQrModal;

            // Error modal close button
            document.getElementById('error-close').onclick = closeErrorModal;

            // Start with URL button on welcome screen
            document.getElementById('start-with-url-btn').onclick = function() {
                document.getElementById('welcome-screen').classList.add('hidden');
                showPdfUrlModal();
            };

            // PDF container scroll listener
            pdfContainer.addEventListener('scroll', window.handleScroll);

            // Close menu when clicking outside
            document.addEventListener('click', (event) => {
                const sideMenu = document.getElementById('side-menu');
                const menuButton = document.getElementById('menu-button');

                if (sideMenu.classList.contains('open') &&
                    !sideMenu.contains(event.target) &&
                    !menuButton.contains(event.target)) {
                    window.toggleMenu();
                }
            });

            // Allow Enter key in PDF URL input
            document.getElementById('pdf-url-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('pdf-url-ok').click();
                }
            });
        });

    </script>
</body>
</html>